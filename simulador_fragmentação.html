<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Fragmentação de Pacotes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 950px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f8f8;
        }
        
        .controls {
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .delay-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        label {
            margin-right: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        button {
            padding: 6px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .timer {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            border: 1px solid #ddd;
        }
        
        .network-container {
            background-color: #ffecec;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            height: 400px;
            border: 2px solid #ff9999;
            overflow: hidden;
        }
        
        .nodes {
            display: flex;
            justify-content: space-between;
            height: 100%;
            position: relative;
        }
        
        .node {
            width: 100px;
            height: 330px;
            background-color: #ffffff;
            border: 2px solid #333;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .node-label {
            position: absolute;
            bottom: -25px;
            text-align: center;
            font-weight: bold;
        }
        
        .links {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            z-index: 0;
        }
        
        .link {
            height: 10px;
            background-color: #99ccff;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            border: 1px solid #0066cc;
        }
        
        #link1 {
            left: 102px;
            width: calc(25% - 102px);
        }
        
        #link2 {
            left: 25%;
            width: 50%;
        }
        
        #link3 {
            right: 102px;
            width: calc(25% - 102px);
        }
        
        .buffer {
            width: 80px;
            height: 300px;
            margin: 5px;
            border: 1px dashed #333;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }
        
        .buffer-label {
            position: absolute;
            top: -20px;
            font-weight: bold;
            color: blue;
        }
        
        .packet {
            width: 60px;
            height: 10px;
            background-color: yellow;
            border: 1px solid #333;
            margin: 2px;
            font-size: 8px;
            text-align: center;
            position: absolute;
            transition: all 0.25s linear;
        }
        
        .simulation-speed {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 40px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        
        .legend-color {
            width: 20px;
            height: 10px;
            border: 1px solid black;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .checkbox-container input {
            margin: 0;
        }
    </style>
</head>
<body>
    <h1>Simulador de Fragmentação de Pacotes em Redes</h1>
    
    <div class="controls">
        <div class="control-group">
            <label for="messageSize">Tamanho da Mensagem (KBs):</label>
            <select id="messageSize">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4">4</option>
                <option value="8">8</option>
                <option value="10" selected>10</option>
                <option value="16">16</option>
                <option value="20">20</option>
                <option value="32">32</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="packetSize">Tamanho do Pacote (KBs):</label>
            <select id="packetSize">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4" selected>4</option>
                <option value="8">8</option>
            </select>
        </div>
        
        <p>* Para mensagens não divisíveis, serão criados fragmentos de 1KB</p>
    </div>
    
    <div class="controls">
        <div class="delay-controls">
            <label>Atraso de Propagação:</label>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL1">
                <label for="delayL1">L1</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL2">
                <label for="delayL2">L2</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL3">
                <label for="delayL3">L3</label>
            </div>
        </div>
        
        <div class="simulation-speed">
            <label>Velocidade da Simulação:</label>
            <input type="range" id="simulationSpeed" min="1" max="10" value="5">
            <span>slow</span>
            <span>fast</span>
        </div>
    </div>
    
    <div class="controls">
        <button id="startBtn">Iniciar</button>
        <button id="pauseBtn" disabled>Pausar</button>
        <button id="resumeBtn" disabled>Continuar</button>
        <button id="stopBtn" disabled>Parar</button>
    </div>
    
    <div class="timer" id="timer">TEMPO DECORRIDO: 0.00</div>
    
    <div class="network-container">
        <div class="links">
            <div class="link" id="link1"></div>
            <div class="link" id="link2"></div>
            <div class="link" id="link3"></div>
        </div>
        
        <div class="nodes">
            <div class="node" id="source">
                <div class="buffer" id="sourceB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="sourceT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">Source</div>
            </div>
            
            <div class="node" id="nodeB">
                <div class="buffer" id="nodeBR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="nodeBB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="nodeBT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">B</div>
            </div>
            
            <div class="node" id="nodeC">
                <div class="buffer" id="nodeCR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="nodeCB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="nodeCT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">C</div>
            </div>
            
            <div class="node" id="destination">
                <div class="buffer" id="destinationR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="destinationB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="node-label">Destination</div>
            </div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: yellow;"></div>
            <span>Pacote de 1KB</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #99ccff;"></div>
            <span>Link (4 KB/s)</span>
        </div>
        <div class="legend-item">
            <span>R: Buffer de recepção</span>
        </div>
        <div class="legend-item">
            <span>B: Buffer interno</span>
        </div>
        <div class="legend-item">
            <span>T: Buffer de transmissão</span>
        </div>
    </div>
    
    <script>
        // Elementos da interface
        const messageSize = document.getElementById('messageSize');
        const packetSize = document.getElementById('packetSize');
        const simulationSpeedControl = document.getElementById('simulationSpeed'); // Renomeado para evitar conflito
        const delayL1 = document.getElementById('delayL1');
        const delayL2 = document.getElementById('delayL2');
        const delayL3 = document.getElementById('delayL3');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerDisplay = document.getElementById('timer');
        
        // Buffers
        const buffers = {
            sourceB: document.getElementById('sourceB'),
            sourceT: document.getElementById('sourceT'),
            nodeBR: document.getElementById('nodeBR'),
            nodeBB: document.getElementById('nodeBB'),
            nodeBT: document.getElementById('nodeBT'),
            nodeCR: document.getElementById('nodeCR'),
            nodeCB: document.getElementById('nodeCB'),
            nodeCT: document.getElementById('nodeCT'),
            destinationR: document.getElementById('destinationR'),
            destinationB: document.getElementById('destinationB')
        };
        
        // Variáveis de controle da simulação
        let simulationRunning = false;
        let simulationPaused = false;
        let calculatedTime = 0; // Tempo calculado real
        let displayTime = 0; // Tempo para a animação
        let timerInterval;
        let animationInterval;
        let packets = []; // Todos os fragmentos criados
        let activePackets = []; // Fragmentos atualmente na rede/buffers
        let currentPacketId = 0;
        
        // Constantes de tempo e tamanho
        const LINK_CAPACITY = 4; // KB/s
        const FRAGMENT_SIZE = 1; // KB por fragmento
        const TRANSMISSION_DELAY_PER_KB = 1 / LINK_CAPACITY; // Tempo para transmitir 1KB (0.25s)
        const PROPAGATION_DELAY_PER_LINK = 1; // 1 segundo por link se selecionado
        
        // Rota para os pacotes
        const route = [
            'sourceB', // Buffer interno source
            'sourceT', // Buffer de transmissão source
            'link1',   // Link 1
            'nodeBR',  // Buffer de recepção nó B
            'nodeBB',  // Buffer interno nó B
            'nodeBT',  // Buffer de transmissão nó B
            'link2',   // Link 2
            'nodeCR',  // Buffer de recepção nó C
            'nodeCB',  // Buffer interno nó C
            'nodeCT',  // Buffer de transmissão nó C
            'link3',   // Link 3
            'destinationR', // Buffer de recepção destino
            'destinationB'  // Buffer interno destino (chegada final)
        ];
        
        // Armazenar o estado dos buffers para o cálculo do tempo
        const bufferStates = {};
        
        // Inicializar os estados dos buffers
        function initializeBufferStates() {
            route.forEach(step => {
                if (!step.startsWith('link')) {
                    bufferStates[step] = {
                        queue: [], // Fragmentos no buffer
                        maxSize: 20 // Capacidade de exemplo para buffers (20 fragmentos)
                    };
                } else {
                    bufferStates[step] = {
                        inTransit: [], // Fragmentos em trânsito no link
                        propagationTime: 0 // Tempo de propagação para este link
                    };
                }
            });
        }
        
        // Função para criar pacotes (fragmentos de 1KB)
        function createPackets() {
            packets = [];
            activePackets = [];
            currentPacketId = 0;
            initializeBufferStates();
        
            const msgSize = parseInt(messageSize.value);
            const pktSize = parseInt(packetSize.value);
            
            const numFullPackets = Math.floor(msgSize / pktSize);
            const remainderFragments = msgSize % pktSize;
            
            let currentPackageId = 0;
        
            for (let i = 0; i < numFullPackets; i++) {
                for (let j = 0; j < pktSize; j++) {
                    const fragment = {
                        id: currentPacketId++,
                        packageId: currentPackageId, // ID único para o pacote "pai"
                        size: FRAGMENT_SIZE, // Sempre 1KB
                        currentRouteIndex: 0,
                        arrivalTime: 0, // Tempo de chegada no buffer/link
                        departureTime: 0, // Tempo de saída do buffer/link
                        transmissionComplete: false,
                        propagationComplete: false,
                        element: null // Referência ao elemento visual
                    };
                    packets.push(fragment);
                    bufferStates['sourceB'].queue.push(fragment); // Coloca no buffer de origem
                }
                currentPackageId++;
            }
        
            if (remainderFragments > 0) {
                for (let j = 0; j < remainderFragments; j++) {
                    const fragment = {
                        id: currentPacketId++,
                        packageId: currentPackageId,
                        size: FRAGMENT_SIZE,
                        currentRouteIndex: 0,
                        arrivalTime: 0,
                        departureTime: 0,
                        transmissionComplete: false,
                        propagationComplete: false,
                        element: null
                    };
                    packets.push(fragment);
                    bufferStates['sourceB'].queue.push(fragment);
                }
            }
            renderPackets();
        }
        
        // Renderizar os pacotes nos buffers
        function renderPackets() {
            // Limpar todos os buffers visuais
            Object.values(buffers).forEach(buffer => {
                const existingPackets = buffer.querySelectorAll('.packet');
                existingPackets.forEach(p => p.remove());
            });
        
            // Renderizar pacotes em seus buffers atuais
            Object.keys(bufferStates).forEach(bufferName => {
                if (!bufferName.startsWith('link')) {
                    const bufferElement = buffers[bufferName];
                    if (bufferElement) {
                        bufferStates[bufferName].queue.forEach((packet, index) => {
                            let packetElement = packet.element;
                            if (!packetElement) {
                                packetElement = document.createElement('div');
                                packetElement.className = 'packet';
                                packetElement.id = `packet-${packet.id}`;
                                packetElement.textContent = `${packet.size}KB`;
                                const colorHue = (packet.packageId * 30) % 360;
                                packetElement.style.backgroundColor = `hsl(${colorHue}, 100%, 70%)`;
                                packet.element = packetElement;
                            }
                            
                            // Posicionar o pacote no buffer baseado na ordem
                            const top = 10 + index * 14; // 14px = altura do pacote + margem
                            packetElement.style.top = `${top}px`;
                            bufferElement.appendChild(packetElement);
                        });
                    }
                }
            });
        }
        
        // Simular o tempo e mover os pacotes
        function simulateNetworkStep() {
            if (!simulationRunning || simulationPaused) return;
        
            const link1Delay = delayL1.checked ? PROPAGATION_DELAY_PER_LINK : 0;
            const link2Delay = delayL2.checked ? PROPAGATION_DELAY_PER_LINK : 0;
            const link3Delay = delayL3.checked ? PROPAGATION_DELAY_PER_LINK : 0;
        
            // Atualizar o tempo da simulação (incremento mínimo para cálculos)
            const deltaTime = 0.01; // 10ms
            calculatedTime += deltaTime;
            displayTime += deltaTime; // Para manter o display atualizado suavemente
            timerDisplay.textContent = `TEMPO DECORRIDO: ${calculatedTime.toFixed(2)}`;
        
            // Lógica de movimentação (do destino para a origem para evitar duplicação)
            for (let i = route.length - 2; i >= 0; i--) {
                const currentStep = route[i];
                const nextStep = route[i + 1];
        
                if (currentStep.startsWith('link')) {
                    // Mover pacotes que terminaram a propagação no link
                    const linkState = bufferStates[currentStep];
                    let packetsToMove = [];
                    linkState.inTransit.forEach(packet => {
                        const propagationTime = (currentStep === 'link1' ? link1Delay :
                                                currentStep === 'link2' ? link2Delay :
                                                currentStep === 'link3' ? link3Delay : 0);
                        if (calculatedTime >= packet.arrivalTime + propagationTime) {
                            packetsToMove.push(packet);
                        }
                    });
        
                    packetsToMove.forEach(packet => {
                        // Remover do link e adicionar ao próximo buffer/destino
                        linkState.inTransit = linkState.inTransit.filter(p => p.id !== packet.id);
                        if (nextStep.startsWith('destinationB')) { // Chegou ao destino final
                             // Pacote concluído
                            packet.currentRouteIndex++;
                            // Remover elemento visual
                            if(packet.element) packet.element.remove();
                        } else {
                            if (bufferStates[nextStep].queue.length < bufferStates[nextStep].maxSize) {
                                bufferStates[nextStep].queue.push(packet);
                                packet.currentRouteIndex++;
                                packet.arrivalTime = calculatedTime; // Tempo de chegada no novo buffer
                            } else {
                                // Buffer cheio, o pacote permanece no link (simples para este simulador)
                                linkState.inTransit.push(packet); // Coloca de volta se não coube
                            }
                        }
                    });
                } else { // É um buffer
                    const currentBufferState = bufferStates[currentStep];
                    const nextBufferState = bufferStates[nextStep];
        
                    // Mover pacotes que terminaram a transmissão do buffer atual para o próximo
                    // Consideramos que cada fragmento de 1KB leva 0.25s para ser transmitido pelo link
                    // e que pacotes de N KB demoram N * 0.25s para saírem do buffer de transmissão.
                    // O primeiro fragmento de um pacote completo inicia a transmissão quando o link está livre.
                    // Os fragmentos subsequentes de um mesmo pacote se seguem em pipeline.
        
                    const packetsInCurrentBuffer = currentBufferState.queue;
        
                    if (packetsInCurrentBuffer.length > 0) {
                        const packetToTransmit = packetsInCurrentBuffer[0];
        
                        let transmissionDuration = FRAGMENT_SIZE * TRANSMISSION_DELAY_PER_KB; // 0.25s para 1KB
        
                        // Para o primeiro fragmento de um novo pacote lógico
                        // Ou o primeiro fragmento a sair de um buffer
                        if (packetToTransmit.transmissionComplete === false) { // Se ainda não começou a transmitir
                             // Calcula o tempo que este fragmento estará pronto para sair do buffer
                            if (currentBufferState.lastDepartureTime === undefined || currentBufferState.lastDepartureTime <= calculatedTime) {
                                packetToTransmit.departureTime = calculatedTime + transmissionDuration;
                                packetToTransmit.transmissionComplete = true; // Marca que o tempo de transmissão foi computado
                            } else {
                                // Se o buffer ainda está ocupado transmitindo um fragmento anterior,
                                // este fragmento espera sua vez.
                                packetToTransmit.departureTime = currentBufferState.lastDepartureTime + transmissionDuration;
                                packetToTransmit.transmissionComplete = true;
                            }
                            currentBufferState.lastDepartureTime = packetToTransmit.departureTime;
                        }
        
                        if (calculatedTime >= packetToTransmit.departureTime) {
                            // Tenta mover para o próximo estágio
                            if (nextStep.startsWith('link')) {
                                if (nextBufferState.inTransit.length === 0 || linkHasCapacity(nextStep, packetToTransmit)) {
                                    // Remove do buffer atual
                                    currentBufferState.queue.shift();
                                    
                                    // Adiciona ao link para propagação
                                    packetToTransmit.arrivalTime = calculatedTime; // Início da propagação
                                    nextBufferState.inTransit.push(packetToTransmit);
                                    packetToTransmit.currentRouteIndex++;
                                    packetToTransmit.transmissionComplete = false; // Reseta para próxima transmissão
                                    currentBufferState.lastDepartureTime = packetToTransmit.departureTime; // Atualiza o tempo de saída do buffer
                                }
                            } else { // Próximo estágio é um buffer
                                if (nextBufferState.queue.length < nextBufferState.maxSize) {
                                    // Remove do buffer atual
                                    currentBufferState.queue.shift();
                                    
                                    // Adiciona ao próximo buffer
                                    nextBufferState.queue.push(packetToTransmit);
                                    packetToTransmit.currentRouteIndex++;
                                    packetToTransmit.arrivalTime = calculatedTime; // Tempo de chegada no novo buffer
                                    packetToTransmit.transmissionComplete = false;
                                    currentBufferState.lastDepartureTime = packetToTransmit.departureTime;
                                }
                            }
                        }
                    }
                }
            }
            renderPackets();
        
            // Verificar se todos os pacotes chegaram ao destino final
            const allPacketsDelivered = packets.every(p => p.currentRouteIndex >= route.length -1);
            if (allPacketsDelivered) {
                stopSimulation();
            }
        }
        
        // Verifica se o link tem capacidade para receber mais pacotes (simplificado, apenas um por link na fila)
        function linkHasCapacity(linkName, packet) {
            // Em uma simulação real, um link pode ter múltiplos pacotes em trânsito.
            // Para este simulador, consideramos que o link transmite um fragmento por vez.
            // A animação já permite múltiplos pacotes no link.
            return true; 
        }
        
        // Iniciar a simulação
        function startSimulation() {
            if (simulationRunning) return;
            
            // Resetar e inicializar
            simulationRunning = true;
            simulationPaused = false;
            calculatedTime = 0;
            displayTime = 0;
            timerDisplay.textContent = `TEMPO DECORRIDO: ${calculatedTime.toFixed(2)}`;
            
            updateButtonStates();
            
            // Criar pacotes com base nas configurações
            createPackets();
            
            // Iniciar o timer e a simulação de movimento
            timerInterval = setInterval(simulateNetworkStep, 10); // Intervalo de 10ms para o cálculo do tempo
            animationInterval = setInterval(renderPackets, animationSpeed); // Intervalo para renderizar a animação
        }
        
        // Pausar a simulação
        function pauseSimulation() {
            if (!simulationRunning || simulationPaused) return;
            
            simulationPaused = true;
            clearInterval(animationInterval); // Pausa a animação
            updateButtonStates();
        }
        
        // Retomar a simulação
        function resumeSimulation() {
            if (!simulationRunning || !simulationPaused) return;
            
            simulationPaused = false;
            animationInterval = setInterval(renderPackets, animationSpeed); // Retoma a animação
            updateButtonStates();
        }
        
        // Parar a simulação
        function stopSimulation() {
            if (!simulationRunning) return;
            
            clearInterval(timerInterval);
            clearInterval(animationInterval);
            simulationRunning = false;
            simulationPaused = false;
            updateButtonStates();
            
            // Limpar todos os pacotes visuais ao parar
            Object.values(buffers).forEach(buffer => {
                const existingPackets = buffer.querySelectorAll('.packet');
                existingPackets.forEach(p => p.remove());
            });
            packets = [];
            activePackets = [];
            initializeBufferStates(); // Resetar o estado dos buffers
            timerDisplay.textContent = `TEMPO DECORRIDO: ${calculatedTime.toFixed(2)}`; // Exibe o tempo final
        }
        
        // Atualizar estados dos botões
        function updateButtonStates() {
            startBtn.disabled = simulationRunning;
            pauseBtn.disabled = !simulationRunning || simulationPaused;
            resumeBtn.disabled = !simulationRunning || !simulationPaused;
            stopBtn.disabled = !simulationRunning;
            
            // Desabilitar configurações durante a simulação
            messageSize.disabled = simulationRunning;
            packetSize.disabled = simulationRunning;
            delayL1.disabled = simulationRunning;
            delayL2.disabled = simulationRunning;
            delayL3.disabled = simulationRunning;
        }
        
        // Event listeners
        startBtn.addEventListener('click', startSimulation);
        pauseBtn.addEventListener('click', pauseSimulation);
        resumeBtn.addEventListener('click', resumeSimulation);
        stopBtn.addEventListener('click', stopSimulation);
        
        simulationSpeedControl.addEventListener('input', () => {
            const speedFactor = parseInt(simulationSpeedControl.value);
            // Ajusta a velocidade da animação: quanto maior o valor, mais rápido
            // BASE_SPEED é o tempo base para cada "passo" visual
            animationSpeed = BASE_SPEED * (11 - speedFactor) / 5; // Ajusta a velocidade inversamente ao slider
            if (simulationRunning && !simulationPaused) {
                clearInterval(animationInterval);
                animationInterval = setInterval(renderPackets, animationSpeed);
            }
        });
        
        // Inicialização
        const BASE_SPEED = 250; // 0.25s para a animação
        let animationSpeed = BASE_SPEED * (11 - parseInt(simulationSpeedControl.value)) / 5;
        
        updateButtonStates();
        initializeBufferStates(); // Garante que os buffers estão limpos no início
    </script>
</body>
</html>