<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Fragmentação de Pacotes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 950px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f8f8;
        }
        
        .controls {
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .delay-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        label {
            margin-right: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        button {
            padding: 6px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .timer {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            border: 1px solid #ddd;
        }
        
        .network-container {
            background-color: #ffecec;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            height: 400px;
            border: 2px solid #ff9999;
            overflow: hidden;
        }
        
        .nodes {
            display: flex;
            justify-content: space-between;
            height: 100%;
            position: relative;
        }
        
        .node {
            width: 100px;
            height: 330px;
            background-color: #ffffff;
            border: 2px solid #333;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .node-label {
            position: absolute;
            bottom: -25px;
            text-align: center;
            font-weight: bold;
        }
        
        .links {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            z-index: 0;
        }
        
        .link {
            height: 10px;
            background-color: #99ccff;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            border: 1px solid #0066cc;
        }
        
        #link1 {
            left: 102px;
            width: calc(25% - 102px);
        }
        
        #link2 {
            left: 25%;
            width: 50%;
        }
        
        #link3 {
            right: 102px;
            width: calc(25% - 102px);
        }
        
        .buffer {
            width: 80px;
            height: 300px;
            margin: 5px;
            border: 1px dashed #333;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }
        
        .buffer-label {
            position: absolute;
            top: -20px;
            font-weight: bold;
            color: blue;
        }
        
        .packet {
            width: 60px;
            height: 10px;
            background-color: yellow;
            border: 1px solid #333;
            margin: 2px;
            font-size: 8px;
            text-align: center;
            position: absolute;
            transition: all 0.1s linear; /* Transição para suavizar movimento entre buffers e em links */
        }
        
        .simulation-speed {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 40px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        
        .legend-color {
            width: 20px;
            height: 10px;
            border: 1px solid black;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .checkbox-container input {
            margin: 0;
        }
    </style>
</head>
<body>
    <h1>Simulador de Fragmentação de Pacotes em Redes</h1>
    
    <div class="controls">
        <div class="control-group">
            <label for="messageSize">Tamanho da Mensagem (KBs):</label>
            <select id="messageSize">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4">4</option>
                <option value="8">8</option>
                <option value="10">10</option>
                <option value="16" selected>16</option> <option value="20">20</option>
                <option value="32">32</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="packetSize">Tamanho do Pacote (KBs):</label>
            <select id="packetSize">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4" selected>4</option> <option value="8">8</option>
            </select>
        </div>
        
        <p>* Para mensagens não divisíveis, serão criados fragmentos de 1KB</p>
    </div>
    
    <div class="controls">
        <div class="delay-controls">
            <label>Atraso de Propagação:</label>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL1">
                <label for="delayL1">L1</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL2">
                <label for="delayL2">L2</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL3">
                <label for="delayL3">L3</label>
            </div>
        </div>
        
        <div class="simulation-speed">
            <label>Velocidade da Simulação:</label>
            <input type="range" id="simulationSpeed" min="1" max="10" value="5">
            <span>slow</span>
            <span>fast</span>
        </div>
    </div>
    
    <div class="controls">
        <button id="startBtn">Iniciar</button>
        <button id="pauseBtn" disabled>Pausar</button>
        <button id="resumeBtn" disabled>Continuar</button>
        <button id="stopBtn" disabled>Parar</button>
    </div>
    
    <div class="timer" id="timer">TEMPO DECORRIDO: 0.00</div>
    
    <div class="network-container">
        <div class="links">
            <div class="link" id="link1"></div>
            <div class="link" id="link2"></div>
            <div class="link" id="link3"></div>
        </div>
        
        <div class="nodes">
            <div class="node" id="source">
                <div class="buffer" id="sourceB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="sourceT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">Source</div>
            </div>
            
            <div class="node" id="nodeB">
                <div class="buffer" id="nodeBR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="nodeBB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="nodeBT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">B</div>
            </div>
            
            <div class="node" id="nodeC">
                <div class="buffer" id="nodeCR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="nodeCB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="nodeCT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">C</div>
            </div>
            
            <div class="node" id="destination">
                <div class="buffer" id="destinationR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="destinationB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="node-label">Destination</div>
            </div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: yellow;"></div>
            <span>Pacote de 1KB</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #99ccff;"></div>
            <span>Link (4 KB/s)</span>
        </div>
        <div class="legend-item">
            <span>R: Buffer de recepção</span>
        </div>
        <div class="legend-item">
            <span>B: Buffer interno</span>
        </div>
        <div class="legend-item">
            <span>T: Buffer de transmissão</span>
        </div>
    </div>
    
    <script>
        // Elementos da interface
        const messageSizeSelect = document.getElementById('messageSize');
        const packetSizeSelect = document.getElementById('packetSize');
        const simulationSpeedInput = document.getElementById('simulationSpeed');
        const delayL1Checkbox = document.getElementById('delayL1');
        const delayL2Checkbox = document.getElementById('delayL2');
        const delayL3Checkbox = document.getElementById('delayL3');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerDisplay = document.getElementById('timer');
        
        // Buffers
        const buffers = {
            sourceB: document.getElementById('sourceB'),
            sourceT: document.getElementById('sourceT'),
            nodeBR: document.getElementById('nodeBR'),
            nodeBB: document.getElementById('nodeBB'),
            nodeBT: document.getElementById('nodeBT'),
            nodeCR: document.getElementById('nodeCR'),
            nodeCB: document.getElementById('nodeCB'),
            nodeCT: document.getElementById('nodeCT'),
            destinationR: document.getElementById('destinationR'),
            destinationB: document.getElementById('destinationB')
        };
        
        // Variáveis de controle da simulação
        let simulationRunning = false;
        let simulationPaused = false;
        let simulationTime = 0; // Tempo real da simulação
        let processInterval;
        let packets = []; // Cada item aqui é um fragmento de 1KB
        let currentFragmentId = 0; // ID para cada fragmento de 1KB
        
        // Constantes da rede
        const KILOBYTE_PER_FRAGMENT = 1; // 1KB por fragmento (unidade visual)
        const LINK_BANDWIDTH_KBS = 4; // 4 KB/s (banda do link)
        // Tempo para 1KB atravessar um link. Cada KB de dados leva 0.25s para ser transmitido.
        const TRANSMISSION_TIME_PER_KB_FRAGMENT = KILOBYTE_PER_FRAGMENT / LINK_BANDWIDTH_KBS; // 0.25s
        const PROPAGATION_DELAY = 0.5; // Atraso de propagação por link em segundos (quando ativado)
        
        // Rota para os pacotes (stages)
        const route = [
            'sourceB',      // 0: Buffer B da origem (geração)
            'sourceT',      // 1: Buffer T da origem (transmissão)
            'link1',        // 2: Link 1
            'nodeBR',       // 3: Buffer R do nó B
            'nodeBB',       // 4: Buffer B do nó B
            'nodeBT',       // 5: Buffer T do nó B
            'link2',        // 6: Link 2
            'nodeCR',       // 7: Buffer R do nó C
            'nodeCB',       // 8: Buffer B do nó C
            'nodeCT',       // 9: Buffer T do nó C
            'link3',        // 10: Link 3
            'destinationR', // 11: Buffer R do destino
            'destinationB'  // 12: Buffer B do destino (consumo final)
        ];
        
        const BASE_ANIMATION_INTERVAL = 50; // Intervalo de atualização da animação em ms
        let animationSpeedFactor = 1;
        
        // Novo: Controla quando cada link estará livre para *iniciar* a transmissão do próximo pacote LÓGICO
        const linkFreeTime = {
            link1: 0,
            link2: 0,
            link3: 0
        };

        // Novo: Armazena o ID do pacote lógico que está sendo transmitido por um link
        const linkCurrentLogicalPacket = {
            link1: null,
            link2: null,
            link3: null
        };
        
        // Função para criar pacotes (fragmentos de 1KB)
        function createPackets() {
            packets = [];
            currentFragmentId = 0; 
            
            const msgSizeKB = parseInt(messageSizeSelect.value);
            const pktSizeKB = parseInt(packetSizeSelect.value); // Tamanho do pacote lógico (ex: 4KB)
            
            // Determina o número de pacotes lógicos (de pktSizeKB KB)
            const numLogicalPackets = Math.ceil(msgSizeKB / pktSizeKB);
            
            for (let i = 0; i < numLogicalPackets; i++) {
                // Calcula quantos KBs reais este pacote lógico terá (o último pode ser menor)
                const currentLogicalPacketKBs = Math.min(pktSizeKB, msgSizeKB - (i * pktSizeKB));
        
                // Cada KB dentro do pacote lógico é um fragmento visual de 1KB
                for (let j = 0; j < currentLogicalPacketKBs; j++) {
                    packets.push({
                        id: currentFragmentId++, // ID único para cada fragmento de 1KB
                        logicalPacketId: i,      // ID do pacote lógico (grupo de fragmentos)
                        routeIndex: 0,           // Posição inicial na rota (sourceB)
                        inTransit: false,        // Se está atualmente em um link
                        // Quando este fragmento TERMINARÁ a propagação no link
                        propagationCompleteTime: 0,
                        // O tempo em que o pacote lógico ao qual este fragmento pertence *começou* a transmitir no link
                        logicalPacketTransmissionStartTimeInLink: {} // Guarda {linkName: time} para animação
                    });
                }
            }
            // Ordenar os pacotes para que os fragments do mesmo pacote lógico fiquem agrupados
            packets.sort((a, b) => a.logicalPacketId - b.logicalPacketId || a.id - b.id);
            
            renderPackets();
        }
        
        // Renderizar os pacotes nos buffers ou links
        function renderPackets() {
            // Limpa todos os pacotes visuais existentes
            Object.values(buffers).forEach(buffer => {
                const existingPackets = buffer.querySelectorAll('.packet');
                existingPackets.forEach(p => p.remove());
            });
            document.getElementById('link1').querySelectorAll('.packet').forEach(p => p.remove());
            document.getElementById('link2').querySelectorAll('.packet').forEach(p => p.remove());
            document.getElementById('link3').querySelectorAll('.packet').forEach(p => p.remove());
        
            packets.forEach(packet => {
                const currentStageName = route[packet.routeIndex];
                const packetElement = document.createElement('div');
                packetElement.className = 'packet';
                packetElement.id = `packet-${packet.id}`;
                packetElement.textContent = `1KB`;
                
                const colorHue = (packet.logicalPacketId * 30) % 360;
                packetElement.style.backgroundColor = `hsl(${colorHue}, 100%, 70%)`;
        
                if (currentStageName.startsWith('link')) {
                    const linkElement = document.getElementById(currentStageName);
                    if (linkElement) {
                        const linkNumber = currentStageName.charAt(4);
                        const hasPropagationDelay = (delayL1Checkbox.checked && linkNumber === '1') ||
                                                    (delayL2Checkbox.checked && linkNumber === '2') ||
                                                    (delayL3Checkbox.checked && linkNumber === '3');
                        const propagationDelay = hasPropagationDelay ? PROPAGATION_DELAY : 0;

                        const pktSizeKB = parseInt(packetSizeSelect.value);
                        const transmissionTimeForFullPacket = pktSizeKB * TRANSMISSION_TIME_PER_KB_FRAGMENT; // E.g., 1s for 4KB
                        
                        // Total time the logical packet spends in the link (transmission + propagation)
                        const totalTimeInLink = transmissionTimeForFullPacket + propagationDelay;
                        
                        // The exact time this logical packet started transmission on this link
                        const linkStartTime = packet.logicalPacketTransmissionStartTimeInLink[currentStageName] || 0;

                        let progress = 0;
                        if (totalTimeInLink > 0 && linkStartTime > 0) {
                            progress = Math.min(1, (simulationTime - linkStartTime) / totalTimeInLink);
                        }
                        
                        const linkWidth = linkElement.offsetWidth;
                        const left = progress * (linkWidth - packetElement.offsetWidth);
                        packetElement.style.left = `${left}px`;
                        packetElement.style.top = `0px`; 
        
                        linkElement.appendChild(packetElement);
                    }
                } else {
                    const bufferElement = buffers[currentStageName];
                    if (bufferElement) {
                        // Posicionar o pacote no buffer baseado na ordem de chegada
                        const fragmentsInBuffer = packets.filter(p =>
                            p.routeIndex === packet.routeIndex && !p.inTransit
                        ).sort((a, b) => a.id - b.id);
                        
                        const position = fragmentsInBuffer.indexOf(packet);
                        if (position !== -1) {
                            const top = 10 + position * 14;
                            packetElement.style.top = `${top}px`;
                            bufferElement.appendChild(packetElement);
                        }
                    }
                }
            });
        }
        
        // Lógica de movimentação dos pacotes
        function processPacketMovement() {
            if (!simulationRunning || simulationPaused) return;
        
            let movedSomethingInThisTick = false;
        
            // Processa do destino para a origem para evitar que um pacote "pule" etapas
            for (let i = route.length - 2; i >= 0; i--) {
                const currentStageName = route[i];
                const nextStageName = route[i + 1];
        
                // Pega os fragmentos que estão no estágio atual
                const fragmentsInCurrentStage = packets.filter(p => p.routeIndex === i).sort((a, b) => a.id - b.id);
        
                if (currentStageName.startsWith('link')) {
                    // Um fragmento está em um link, verificamos se terminou a propagação
                    fragmentsInCurrentStage.forEach(fragment => {
                        if (simulationTime >= fragment.propagationCompleteTime) {
                            const nextBufferElement = buffers[nextStageName];
                            const packetsInNextBuffer = packets.filter(p => p.routeIndex === (i + 1) && !p.inTransit).length;
                            const nextBufferCapacity = 20; // Capacidade dos buffers
                            
                            if (packetsInNextBuffer < nextBufferCapacity) {
                                fragment.routeIndex++;
                                fragment.inTransit = false; // Sai do link, entra no buffer
                                movedSomethingInThisTick = true;
                            }
                        }
                    });
        
                    // Lógica para liberar o "lock" do link (pacote completo)
                    const linkName = currentStageName;
                    const pktSizeKB = parseInt(packetSizeSelect.value);
                    const totalKBsInMessage = parseInt(messageSizeSelect.value);

                    // Se o link está atualmente ocupado por um pacote lógico...
                    if (linkCurrentLogicalPacket[linkName] !== null) {
                        const logicalPacketIdBeingTransmitted = linkCurrentLogicalPacket[linkName];
                        const expectedFragmentsForThisLogicalPacket = Math.min(pktSizeKB, totalKBsInMessage - (logicalPacketIdBeingTransmitted * pktSizeKB));

                        // Verifica quantos fragmentos do pacote lógico transmitido já chegaram no próximo estágio
                        const fragmentsArrivedAtNextStage = packets.filter(p => 
                            p.logicalPacketId === logicalPacketIdBeingTransmitted && 
                            p.routeIndex === (i + 1) // Já está no próximo buffer/nó
                        ).length;

                        // Se todos os fragmentos do pacote lógico transmitido já chegaram ao próximo estágio,
                        // e o tempo de transmissão do pacote completo já passou
                        const transmissionTimeForFullPacket = pktSizeKB * TRANSMISSION_TIME_PER_KB_FRAGMENT;
                        const linkStartTimeForLogicalPacket = packets.find(p => p.logicalPacketId === logicalPacketIdBeingTransmitted && p.logicalPacketTransmissionStartTimeInLink[linkName])?.logicalPacketTransmissionStartTimeInLink[linkName] || 0;
                        
                        if (fragmentsArrivedAtNextStage === expectedFragmentsForThisLogicalPacket && 
                            simulationTime >= (linkStartTimeForLogicalPacket + transmissionTimeForFullPacket) ) {
                            linkCurrentLogicalPacket[linkName] = null; // Libera o link
                        }
                    }
        
                } else { // O estágio atual é um buffer (sourceB, sourceT, nodeBR, etc.)
                    const nextStageIsLink = nextStageName.startsWith('link');
                    const fragmentsInCurrentBuffer = packets.filter(p => p.routeIndex === i && !p.inTransit);
                    
                    if (nextStageIsLink && currentStageName.endsWith('T')) { // Se for um buffer de transmissão (SourceT, NodeBT, NodeCT)
                        const linkName = nextStageName;
                        const pktSizeKB = parseInt(packetSizeSelect.value); // Tamanho do pacote lógico (ex: 4KB)
                        
                        // Verifica se o link está livre para INICIAR a transmissão de um novo pacote lógico
                        // E se não há um pacote lógico já sendo transmitido por este link
                        if (simulationTime >= linkFreeTime[linkName] && linkCurrentLogicalPacket[linkName] === null) {
                            let nextLogicalPacketIdToTransmit = -1;
                            if (fragmentsInCurrentBuffer.length > 0) {
                                // Pega o logicalPacketId do primeiro fragmento no buffer
                                nextLogicalPacketIdToTransmit = fragmentsInCurrentBuffer[0].logicalPacketId;
                            }
        
                            if (nextLogicalPacketIdToTransmit !== -1) {
                                // Pega todos os fragmentos pertencentes a este pacote lógico que estão neste buffer
                                const fragmentsForThisLogicalPacket = packets.filter(p => 
                                    p.logicalPacketId === nextLogicalPacketIdToTransmit && 
                                    p.routeIndex === i
                                ).sort((a,b) => a.id - b.id);
        
                                // Calcula o número de fragmentos esperados para este pacote lógico
                                const totalKBsInMessage = parseInt(messageSizeSelect.value);
                                const expectedFragmentsForThisLogicalPacket = Math.min(pktSizeKB, totalKBsInMessage - (nextLogicalPacketIdToTransmit * pktSizeKB));
        
                                // Se temos todos os fragmentos necessários para este pacote lógico
                                if (fragmentsForThisLogicalPacket.length === expectedFragmentsForThisLogicalPacket) {
                                    const transmissionTimeForFullPacket = pktSizeKB * TRANSMISSION_TIME_PER_KB_FRAGMENT; // Ex: 4KB * 0.25s/KB = 1s
                                    
                                    const linkNumber = linkName.charAt(4);
                                    const hasPropagationDelay = (delayL1Checkbox.checked && linkNumber === '1') ||
                                                                (delayL2Checkbox.checked && linkNumber === '2') ||
                                                                (delayL3Checkbox.checked && linkNumber === '3');
                                    const propagationTimeForThisLink = hasPropagationDelay ? PROPAGATION_DELAY : 0;
        
                                    // Define quando o link estará livre para o PRÓXIMO pacote lógico
                                    linkFreeTime[linkName] = simulationTime + transmissionTimeForFullPacket;
                                    // Bloqueia o link com este pacote lógico
                                    linkCurrentLogicalPacket[linkName] = nextLogicalPacketIdToTransmit; 
                                    
                                    // Move todos os fragmentos deste pacote lógico para o link
                                    fragmentsForThisLogicalPacket.forEach(fragment => {
                                        fragment.routeIndex++; // Move o fragmento para o link
                                        fragment.inTransit = true; // Marca como em trânsito no link
                                        // O tempo de término da propagação do fragmento é o tempo de início do PACOTE LÓGICO + o tempo de transmissão do PACOTE LÓGICO + o tempo de propagação do LINK
                                        fragment.propagationCompleteTime = simulationTime + transmissionTimeForFullPacket + propagationTimeForThisLink;
                                        // Registra o tempo de início para a animação
                                        fragment.logicalPacketTransmissionStartTimeInLink[linkName] = simulationTime;
                                        movedSomethingInThisTick = true;
                                    });
                                }
                            }
                        }
                    } else { // Movimentação entre buffers (B, R, T) ou para o destino
                        const packetsInNextBufferCount = packets.filter(p => p.routeIndex === (i + 1) && !p.inTransit).length;
                        const nextBufferCapacity = 20; 
                        
                        if (fragmentsInCurrentBuffer.length > 0 && packetsInNextBufferCount < nextBufferCapacity) {
                            const fragmentToMove = fragmentsInCurrentBuffer[0];
        
                            // Apenas move se não estiver em trânsito por um link
                            if (!fragmentToMove.inTransit) {
                                fragmentToMove.routeIndex++;
                                movedSomethingInThisTick = true;
                            }
                        }
                    }
                }
            }
        
            if (movedSomethingInThisTick) {
                renderPackets();
            }
        
            // Verifica se todos os pacotes chegaram ao destino final (destinationB)
            // Pacotes são considerados entregues quando estão no destinationB e não estão em trânsito (ou seja, estão 'estacionados' lá)
            const allFragmentsDelivered = packets.every(p => p.routeIndex === route.indexOf('destinationB') && !p.inTransit);
            if (allFragmentsDelivered && packets.length > 0) {
                stopSimulation();
            }
        }
        
        // Iniciar a simulação
        function startSimulation() {
            if (simulationRunning) return;
            
            simulationRunning = true;
            simulationPaused = false;
            simulationTime = 0;
            timerDisplay.textContent = `TEMPO DECORRIDO: ${simulationTime.toFixed(2)}`;
            
            // Reset link states
            Object.keys(linkFreeTime).forEach(link => {
                linkFreeTime[link] = 0;
                linkCurrentLogicalPacket[link] = null;
            });
            
            updateButtonStates();
            createPackets();
            
            processInterval = setInterval(() => {
                if (!simulationPaused) {
                    simulationTime += (BASE_ANIMATION_INTERVAL / 1000) * animationSpeedFactor;
                    timerDisplay.textContent = `TEMPO DECORRIDO: ${simulationTime.toFixed(2)}`;
                    processPacketMovement();
                }
            }, BASE_ANIMATION_INTERVAL / animationSpeedFactor);
        }
        
        // Pausar a simulação
        function pauseSimulation() {
            if (!simulationRunning || simulationPaused) return;
            
            simulationPaused = true;
            updateButtonStates();
        }
        
        // Retomar a simulação
        function resumeSimulation() {
            if (!simulationRunning || !simulationPaused) return;
            
            simulationPaused = false;
            updateButtonStates();
        }
        
        // Parar a simulação
        function stopSimulation() {
            if (!simulationRunning) return;
            
            clearInterval(processInterval);
            simulationRunning = false;
            simulationPaused = false;
            updateButtonStates();
            renderPackets(); // Força uma renderização final para garantir que tudo esteja no lugar
        }
        
        // Atualizar estados dos botões
        function updateButtonStates() {
            startBtn.disabled = simulationRunning;
            pauseBtn.disabled = !simulationRunning || simulationPaused;
            resumeBtn.disabled = !simulationRunning || !simulationPaused;
            stopBtn.disabled = !simulationRunning;
            
            messageSizeSelect.disabled = simulationRunning;
            packetSizeSelect.disabled = simulationRunning;
            delayL1Checkbox.disabled = simulationRunning;
            delayL2Checkbox.disabled = simulationRunning;
            delayL3Checkbox.disabled = simulationRunning;
            simulationSpeedInput.disabled = simulationRunning;
        }
        
        // Event listeners
        startBtn.addEventListener('click', startSimulation);
        pauseBtn.addEventListener('click', pauseSimulation);
        resumeBtn.addEventListener('click', resumeSimulation);
        stopBtn.addEventListener('click', stopSimulation);
        
        simulationSpeedInput.addEventListener('input', () => {
            const speedValue = parseInt(simulationSpeedInput.value);
            animationSpeedFactor = speedValue / 5; // Ajusta a velocidade de 0.2x (slow) a 2x (fast)
            
            // Se a simulação estiver rodando, ajusta o intervalo imediatamente para refletir a nova velocidade
            if (simulationRunning && !simulationPaused) {
                clearInterval(processInterval);
                processInterval = setInterval(() => {
                    simulationTime += (BASE_ANIMATION_INTERVAL / 1000) * animationSpeedFactor;
                    timerDisplay.textContent = `TEMPO DECORRIDO: ${simulationTime.toFixed(2)}`;
                    processPacketMovement();
                }, BASE_ANIMATION_INTERVAL / animationSpeedFactor);
            }
        });
        
        // Inicialização
        updateButtonStates();
        animationSpeedFactor = parseInt(simulationSpeedInput.value) / 5; 
        createPackets(); // Cria os pacotes iniciais para visualização ao carregar a página
    </script>
</body>
</html>