<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Fragmentação de Pacotes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 950px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        
        .control-group label {
            margin-right: 8px;
            font-weight: bold;
        }

        select, button {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            margin-right: 5px;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .simulation-area {
            position: relative;
            border: 1px solid #ddd;
            padding: 20px;
            margin-top: 20px;
            border-radius: 6px;
            min-height: 380px;
            background-color: #ffebee;
        }
        
        .time-display {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            padding: 8px;
            margin-bottom: 20px;
            color: #d32f2f;
        }
        
        .network {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 300px;
            position: relative;
        }
        
        .node {
            width: 100px;
            height: 150px;
            background-color: #e3f2fd;
            border: 2px solid #2196F3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 10;
        }
        
        .node-title {
            background-color: #2196F3;
            color: white;
            width: 100%;
            text-align: center;
            padding: 5px 0;
            font-weight: bold;
        }
        
        .buffer-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            justify-content: space-around;
            align-items: center;
            padding: 5px;
        }
        
        .buffer {
            width: 90%;
            height: 25px;
            background-color: #fafafa;
            border: 1px solid #999;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        .link {
            height: 20px;
            background-color: #bbdefb;
            border: 2px solid #1976D2;
            position: absolute;
            z-index: 5;
        }
        
        #link1 {
            width: 13%;
            left: 15%;
            top: 50%;
        }
        
        #link2 {
            width: 13%;
            left: 43%;
            top: 50%;
        }
        
        #link3 {
            width: 13%;
            left: 71%;
            top: 50%;
        }
        
        .packet {
            position: absolute;
            height: 20px;
            background: linear-gradient(to right, yellow, lime);
            border: 1px solid black;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            transition: all 0.5s ease;
            cursor: pointer;
        }
        
        .packet.fragment {
            border: 1px dashed red;
        }
        
        .legend {
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border: 1px solid black;
        }
        
        .legend-packet {
            background: linear-gradient(to right, yellow, lime);
        }
        
        .legend-fragment {
            background: linear-gradient(to right, yellow, lime);
            border: 1px dashed red;
        }
        
        .legend-r {
            background-color: #fafafa;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }
        
        .legend-b {
            background-color: #fafafa;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }
        
        .legend-t {
            background-color: #fafafa;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }

        .delay-controls {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .delay-controls label {
            margin-right: 10px;
        }

        .delay-checkbox {
            margin-right: 20px;
        }

        .speed-control {
            display: flex;
            align-items: center;
        }

        .speed-label {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simulador de Fragmentação de Pacotes</h1>
        
        <div class="controls">
            <div>
                <div class="control-group">
                    <label for="messageSize">Tamanho da Mensagem (KB):</label>
                    <select id="messageSize">
                        <option value="10">10</option>
                        <option value="15">15</option>
                        <option value="20">20</option>
                        <option value="25">25</option>
                        <option value="30">30</option>
                        <option value="35">35</option>
                        <option value="40">40</option>
                        <option value="45">45</option>
                        <option value="50">50</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="packetSize">Tamanho do Pacote (KB):</label>
                    <select id="packetSize">
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="9">9</option>
                        <option value="10">10</option>
                    </select>
                </div>
                
                <div class="delay-controls">
                    <label>Delay de Propagação:</label>
                    <div class="delay-checkbox">
                        <input type="checkbox" id="delayL1">
                        <label for="delayL1">L1</label>
                    </div>
                    <div class="delay-checkbox">
                        <input type="checkbox" id="delayL2">
                        <label for="delayL2">L2</label>
                    </div>
                    <div class="delay-checkbox">
                        <input type="checkbox" id="delayL3">
                        <label for="delayL3">L3</label>
                    </div>
                </div>
                
                <div class="speed-control">
                    <span class="speed-label">Velocidade:</span>
                    <span>Slow</span>
                    <input type="range" id="speedControl" min="1" max="5" value="3">
                    <span>Fast</span>
                </div>
            </div>
            
            <div>
                <button id="startBtn">Iniciar</button>
                <button id="pauseBtn" disabled>Pausar</button>
                <button id="resumeBtn" disabled>Continuar</button>
                <button id="stopBtn" disabled>Parar</button>
            </div>
        </div>
        
        <div class="simulation-area">
            <div class="time-display">TEMPO DECORRIDO: 0.00</div>
            
            <div class="network">
                <div class="node" id="source">
                    <div class="node-title">Origem</div>
                    <div class="buffer-container">
                        <div class="buffer source-buffer-b">B: buffer interno</div>
                        <div class="buffer source-buffer-t">T: transmit buffer</div>
                    </div>
                </div>
                
                <div class="node" id="nodeB">
                    <div class="node-title">B</div>
                    <div class="buffer-container">
                        <div class="buffer nodeB-buffer-r">R: receive buffer</div>
                        <div class="buffer nodeB-buffer-b">B: buffer interno</div>
                        <div class="buffer nodeB-buffer-t">T: transmit buffer</div>
                    </div>
                </div>
                
                <div class="node" id="nodeC">
                    <div class="node-title">C</div>
                    <div class="buffer-container">
                        <div class="buffer nodeC-buffer-r">R: receive buffer</div>
                        <div class="buffer nodeC-buffer-b">B: buffer interno</div>
                        <div class="buffer nodeC-buffer-t">T: transmit buffer</div>
                    </div>
                </div>
                
                <div class="node" id="destination">
                    <div class="node-title">Destino</div>
                    <div class="buffer-container">
                        <div class="buffer dest-buffer-r">R: receive buffer</div>
                        <div class="buffer dest-buffer-b">B: buffer interno</div>
                    </div>
                </div>
                
                <div class="link" id="link1">L1</div>
                <div class="link" id="link2">L2</div>
                <div class="link" id="link3">L3</div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color legend-packet"></div>
                <span>Pacote Completo</span>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-fragment"></div>
                <span>Fragmento</span>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-r">R</div>
                <span>Buffer de Recepção</span>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-b">B</div>
                <span>Buffer Interno</span>
            </div>
            <div class="legend-item">
                <div class="legend-color legend-t">T</div>
                <span>Buffer de Transmissão</span>
            </div>
        </div>
    </div>

    <script>
        // Configurações e variáveis globais
        let simulationRunning = false;
        let simulationPaused = false;
        let elapsedTime = 0;
        let timerInterval;
        let packets = [];
        let currentSimulation = null;

        // Elementos DOM
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timeDisplay = document.querySelector('.time-display');
        const messageSizeSelect = document.getElementById('messageSize');
        const packetSizeSelect = document.getElementById('packetSize');
        const speedControl = document.getElementById('speedControl');
        const delayL1 = document.getElementById('delayL1');
        const delayL2 = document.getElementById('delayL2');
        const delayL3 = document.getElementById('delayL3');
        const simulationArea = document.querySelector('.simulation-area');

        // Coordenadas dos buffers e links (serão definidas dinamicamente)
        let bufferCoordinates = {};
        let linkCoordinates = {};

        // Event listeners
        startBtn.addEventListener('click', startSimulation);
        pauseBtn.addEventListener('click', pauseSimulation);
        resumeBtn.addEventListener('click', resumeSimulation);
        stopBtn.addEventListener('click', stopSimulation);

        // Calcular coordenadas dos elementos
        function calculateCoordinates() {
            const nodes = document.querySelectorAll('.node');
            
            // Coordenadas dos buffers
            bufferCoordinates = {
                'source-b': getElementPosition(document.querySelector('.source-buffer-b')),
                'source-t': getElementPosition(document.querySelector('.source-buffer-t')),
                'nodeB-r': getElementPosition(document.querySelector('.nodeB-buffer-r')),
                'nodeB-b': getElementPosition(document.querySelector('.nodeB-buffer-b')),
                'nodeB-t': getElementPosition(document.querySelector('.nodeB-buffer-t')),
                'nodeC-r': getElementPosition(document.querySelector('.nodeC-buffer-r')),
                'nodeC-b': getElementPosition(document.querySelector('.nodeC-buffer-b')),
                'nodeC-t': getElementPosition(document.querySelector('.nodeC-buffer-t')),
                'dest-r': getElementPosition(document.querySelector('.dest-buffer-r')),
                'dest-b': getElementPosition(document.querySelector('.dest-buffer-b'))
            };
            
            // Coordenadas dos links
            linkCoordinates = {
                'link1': getElementPosition(document.getElementById('link1')),
                'link2': getElementPosition(document.getElementById('link2')),
                'link3': getElementPosition(document.getElementById('link3'))
            };
        }

        // Obter a posição de um elemento em relação à área de simulação
        function getElementPosition(element) {
            const rect = element.getBoundingClientRect();
            const parentRect = simulationArea.getBoundingClientRect();
            
            return {
                left: rect.left - parentRect.left,
                top: rect.top - parentRect.top,
                width: rect.width,
                height: rect.height,
                right: rect.right - parentRect.left,
                bottom: rect.bottom - parentRect.top
            };
        }

        // Iniciar a simulação
        function startSimulation() {
            if (simulationRunning) return;
            
            // Resetar estado
            clearSimulation();
            calculateCoordinates();
            
            // Habilitar/desabilitar botões
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            resumeBtn.disabled = true;
            stopBtn.disabled = false;
            
            // Iniciar timer
            elapsedTime = 0;
            updateTimeDisplay();
            timerInterval = setInterval(updateTimer, 10);
            
            // Iniciar a simulação
            simulationRunning = true;
            simulationPaused = false;
            
            // Configurações da simulação
            const messageSize = parseInt(messageSizeSelect.value);
            const packetSize = parseInt(packetSizeSelect.value);
            const hasDelayL1 = delayL1.checked;
            const hasDelayL2 = delayL2.checked;
            const hasDelayL3 = delayL3.checked;
            const speed = parseInt(speedControl.value);
            
            // Criar pacotes
            createPackets(messageSize, packetSize);
            
            // Iniciar movimento dos pacotes
            startPacketMovement(speed, hasDelayL1, hasDelayL2, hasDelayL3);
        }

        // Criar os pacotes baseados no tamanho da mensagem e do pacote
        function createPackets(messageSize, packetSize) {
            packets = [];
            const numFullPackets = Math.floor(messageSize / packetSize);
            const remainingSize = messageSize % packetSize;
            
            // Criar pacotes completos
            for (let i = 0; i < numFullPackets; i++) {
                packets.push({
                    id: i + 1,
                    size: packetSize,
                    isFragment: false,
                    position: 'source-b', // Posição inicial
                    element: null,
                    completed: false
                });
            }
            
            // Criar fragmento se necessário
            if (remainingSize > 0) {
                packets.push({
                    id: numFullPackets + 1,
                    size: remainingSize,
                    isFragment: true,
                    position: 'source-b',
                    element: null,
                    completed: false
                });
            }
            
            // Criar elementos visuais para os pacotes
            createPacketElements();
        }

        // Criar elementos visuais para os pacotes
        function createPacketElements() {
            packets.forEach((packet, index) => {
                const packetElement = document.createElement('div');
                packetElement.classList.add('packet');
                if (packet.isFragment) {
                    packetElement.classList.add('fragment');
                }
                
                // Tamanho visual baseado no tamanho do pacote (1KB = 3px de largura)
                const width = packet.size * 3;
                packetElement.style.width = `${width}px`;
                
                // Texto para identificar o pacote
                packetElement.textContent = `P${packet.id} (${packet.size}KB)`;
                
                // Posicionar na origem
                const sourceBuffer = bufferCoordinates['source-b'];
                packetElement.style.left = `${sourceBuffer.left + (index * 5)}px`;
                packetElement.style.top = `${sourceBuffer.top + 2}px`;
                
                // Adicionar ao DOM
                simulationArea.appendChild(packetElement);
                packet.element = packetElement;
                
                // Adicionar tooltip para mostrar informações detalhadas
                packetElement.title = `Pacote ${packet.id} - Tamanho: ${packet.size}KB - ${packet.isFragment ? 'Fragmento' : 'Pacote Completo'}`;
            });
        }

        // Iniciar o movimento dos pacotes na rede
        function startPacketMovement(speed, hasDelayL1, hasDelayL2, hasDelayL3) {
            const baseDelay = 600 / speed; // Tempo base para movimento entre buffers
            const propagationDelay = 300 / speed; // Delay de propagação adicional
            
            let packetIndex = 0;
            
            // Caminho que cada pacote deve seguir
            const path = [
                'source-b', 'source-t',  // Origem
                'link1',                 // Link 1
                'nodeB-r', 'nodeB-b', 'nodeB-t', // Nó B
                'link2',                 // Link 2
                'nodeC-r', 'nodeC-b', 'nodeC-t', // Nó C
                'link3',                 // Link 3
                'dest-r', 'dest-b'       // Destino
            ];
            
            function moveNextPacket() {
                if (!simulationRunning || simulationPaused || packetIndex >= packets.length) {
                    if (packetIndex >= packets.length && packets.every(p => p.completed)) {
                        // Todos os pacotes chegaram ao destino
                        setTimeout(() => {
                            stopSimulation(true);
                        }, 500);
                    }
                    return;
                }
                
                const packet = packets[packetIndex];
                let currentPathIndex = path.indexOf(packet.position);
                let nextPosition = path[currentPathIndex + 1];
                
                if (!nextPosition) {
                    // Pacote chegou ao destino final
                    packet.completed = true;
                    packetIndex++;
                    setTimeout(moveNextPacket, baseDelay);
                    return;
                }
                
                // Atualizar posição do pacote
                packet.position = nextPosition;
                
                // Calcular delay adicional para links com delay de propagação
                let additionalDelay = 0;
                if (nextPosition === 'link1' && hasDelayL1) additionalDelay = propagationDelay;
                if (nextPosition === 'link2' && hasDelayL2) additionalDelay = propagationDelay;
                if (nextPosition === 'link3' && hasDelayL3) additionalDelay = propagationDelay;
                
                // Animar o movimento do pacote
                animatePacketMovement(packet, nextPosition);
                
                // Programar o próximo movimento
                let nextDelay = baseDelay + additionalDelay;
                
                if (nextPosition === 'dest-b') {
                    // Pacote completou o percurso, mover para o próximo pacote
                    packet.completed = true;
                    packetIndex++;
                    setTimeout(moveNextPacket, nextDelay);
                } else {
                    // Continuar movendo o mesmo pacote
                    setTimeout(() => {
                        moveNextPacket();
                    }, nextDelay);
                }
            }
            
            // Iniciar a movimentação do primeiro pacote
            moveNextPacket();
        }

        // Animar o movimento do pacote para a próxima posição
        function animatePacketMovement(packet, nextPosition) {
            if (!packet.element) return;
            
            let targetPos;
            
            if (nextPosition.startsWith('link')) {
                // Movimento para um link
                targetPos = {
                    left: linkCoordinates[nextPosition].left + (linkCoordinates[nextPosition].width / 2) - (packet.element.offsetWidth / 2),
                    top: linkCoordinates[nextPosition].top + (linkCoordinates[nextPosition].height / 2) - (packet.element.offsetHeight / 2)
                };
            } else {
                // Movimento para um buffer
                const [nodeId, bufferType] = nextPosition.split('-');
                const bufferKey = nextPosition;
                
                targetPos = {
                    left: bufferCoordinates[bufferKey].left + (bufferCoordinates[bufferKey].width / 2) - (packet.element.offsetWidth / 2),
                    top: bufferCoordinates[bufferKey].top + (bufferCoordinates[bufferKey].height / 2) - (packet.element.offsetHeight / 2)
                };
            }
            
            // Aplicar a animação
            packet.element.style.transition = 'all 0.3s ease';
            packet.element.style.left = `${targetPos.left}px`;
            packet.element.style.top = `${targetPos.top}px`;
        }

        // Pausar a simulação
        function pauseSimulation() {
            if (!simulationRunning || simulationPaused) return;
            
            clearInterval(timerInterval);
            simulationPaused = true;
            
            pauseBtn.disabled = true;
            resumeBtn.disabled = false;
        }

        // Retomar a simulação
        function resumeSimulation() {
            if (!simulationRunning || !simulationPaused) return;
            
            timerInterval = setInterval(updateTimer, 10);
            simulationPaused = false;
            
            pauseBtn.disabled = false;
            resumeBtn.disabled = true;
        }

        // Parar a simulação
        function stopSimulation(completed = false) {
            if (!simulationRunning) return;
            
            clearInterval(timerInterval);
            simulationRunning = false;
            simulationPaused = false;
            
            // Atualizar botões
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            resumeBtn.disabled = true;
            stopBtn.disabled = true;
            
            if (completed) {
                // Destacar que a simulação foi concluída com sucesso
                timeDisplay.innerHTML = `SIMULAÇÃO COMPLETA - TEMPO TOTAL: ${elapsedTime.toFixed(2)}`;
                timeDisplay.style.color = '#4CAF50';
            }
        }

        // Limpar a simulação atual
        function clearSimulation() {
            // Remover pacotes existentes
            packets.forEach(packet => {
                if (packet.element) {
                    packet.element.remove();
                }
            });
            
            packets = [];
            elapsedTime = 0;
            updateTimeDisplay();
            
            // Resetar o estilo do tempo
            timeDisplay.style.color = '#d32f2f';
        }

        // Atualizar o timer
        function updateTimer() {
            elapsedTime += 0.01;
            updateTimeDisplay();
        }

        // Atualizar o display do tempo
        function updateTimeDisplay() {
            timeDisplay.textContent = `TEMPO DECORRIDO: ${elapsedTime.toFixed(2)}`;
        }

        // Garantir que os elementos tenham tamanhos corretos ao iniciar
        window.addEventListener('load', () => {
            calculateCoordinates();
        });

        // Recalcular coordenadas ao redimensionar a janela
        window.addEventListener('resize', () => {
            if (!simulationRunning) {
                calculateCoordinates();
            }
        });
    </script>
</body>
</html>