<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Fragmentação de Pacotes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 950px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f8f8;
        }
        
        .controls {
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .delay-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        label {
            margin-right: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        button {
            padding: 6px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .timer {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            border: 1px solid #ddd;
        }
        
        .network-container {
            background-color: #ffecec;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            height: 400px;
            border: 2px solid #ff9999;
            overflow: hidden;
        }
        
        .nodes {
            display: flex;
            justify-content: space-between;
            height: 100%;
            position: relative;
        }
        
        .node {
            width: 100px;
            height: 330px;
            background-color: #ffffff;
            border: 2px solid #333;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .node-label {
            position: absolute;
            bottom: -25px;
            text-align: center;
            font-weight: bold;
        }
        
        .links {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            z-index: 0;
        }
        
        .link {
            height: 10px;
            background-color: #99ccff;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            border: 1px solid #0066cc;
        }
        
        #link1 {
            left: 102px;
            width: calc(25% - 102px);
        }
        
        #link2 {
            left: 25%;
            width: 50%;
        }
        
        #link3 {
            right: 102px;
            width: calc(25% - 102px);
        }
        
        .buffer {
            width: 80px;
            height: 300px;
            margin: 5px;
            border: 1px dashed #333;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }
        
        .buffer-label {
            position: absolute;
            top: -20px;
            font-weight: bold;
            color: blue;
        }
        
        .packet {
            width: 60px;
            height: 10px;
            background-color: yellow;
            border: 1px solid #333;
            margin: 2px;
            font-size: 8px;
            text-align: center;
            position: absolute;
            transition: all 0.25s linear;
        }
        
        .simulation-speed {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 40px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        
        .legend-color {
            width: 20px;
            height: 10px;
            border: 1px solid black;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .checkbox-container input {
            margin: 0;
        }
    </style>
</head>
<body>
    <h1>Simulador de Fragmentação de Pacotes em Redes</h1>
    
    <div class="controls">
        <div class="control-group">
            <label for="messageSize">Tamanho da Mensagem (KBs):</label>
            <select id="messageSize">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4">4</option>
                <option value="8">8</option>
                <option value="10" selected>10</option>
                <option value="16">16</option>
                <option value="20">20</option>
                <option value="32">32</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="packetSize">Tamanho do Pacote (KBs):</label>
            <select id="packetSize">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4" selected>4</option>
                <option value="8">8</option>
            </select>
        </div>
        
        <p>* Para mensagens não divisíveis, serão criados fragmentos de 1KB</p>
    </div>
    
    <div class="controls">
        <div class="delay-controls">
            <label>Atraso de Propagação (0.5s por link):</label>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL1">
                <label for="delayL1">L1</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL2">
                <label for="delayL2">L2</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="delayL3">
                <label for="delayL3">L3</label>
            </div>
        </div>
        
        <div class="simulation-speed">
            <label>Velocidade da Simulação:</label>
            <input type="range" id="simulationSpeed" min="1" max="10" value="5">
            <span>slow</span>
            <span>fast</span>
        </div>
    </div>
    
    <div class="controls">
        <button id="startBtn">Iniciar</button>
        <button id="pauseBtn" disabled>Pausar</button>
        <button id="resumeBtn" disabled>Continuar</button>
        <button id="stopBtn" disabled>Parar</button>
    </div>
    
    <div class="timer" id="timer">TEMPO DECORRIDO: 0.00</div>
    
    <div class="network-container">
        <div class="links">
            <div class="link" id="link1"></div>
            <div class="link" id="link2"></div>
            <div class="link" id="link3"></div>
        </div>
        
        <div class="nodes">
            <div class="node" id="source">
                <div class="buffer" id="sourceB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="sourceT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">Source</div>
            </div>
            
            <div class="node" id="nodeB">
                <div class="buffer" id="nodeBR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="nodeBB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="nodeBT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">B</div>
            </div>
            
            <div class="node" id="nodeC">
                <div class="buffer" id="nodeCR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="nodeCB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="nodeCT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">C</div>
            </div>
            
            <div class="node" id="destination">
                <div class="buffer" id="destinationR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="destinationB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="node-label">Destination</div>
            </div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: yellow;"></div>
            <span>Pacote de 1KB</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #99ccff;"></div>
            <span>Link (4 KB/s)</span>
        </div>
        <div class="legend-item">
            <span>R: Buffer de recepção</span>
        </div>
        <div class="legend-item">
            <span>B: Buffer interno</span>
        </div>
        <div class="legend-item">
            <span>T: Buffer de transmissão</span>
        </div>
    </div>
    
    <script>
        // Elementos da interface
        const messageSize = document.getElementById('messageSize');
        const packetSize = document.getElementById('packetSize');
        const simulationSpeed = document.getElementById('simulationSpeed');
        const delayL1 = document.getElementById('delayL1');
        const delayL2 = document.getElementById('delayL2');
        const delayL3 = document.getElementById('delayL3');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerDisplay = document.getElementById('timer');
        
        // Buffers
        const buffers = {
            sourceB: document.getElementById('sourceB'),
            sourceT: document.getElementById('sourceT'),
            nodeBR: document.getElementById('nodeBR'),
            nodeBB: document.getElementById('nodeBB'),
            nodeBT: document.getElementById('nodeBT'),
            nodeCR: document.getElementById('nodeCR'),
            nodeCB: document.getElementById('nodeCB'),
            nodeCT: document.getElementById('nodeCT'),
            destinationR: document.getElementById('destinationR'),
            destinationB: document.getElementById('destinationB')
        };
        
        // Variáveis de controle da simulação
        let simulationRunning = false;
        let simulationPaused = false;
        let simulationTime = 0;
        let timerInterval;
        let animationFrameId; // Para animação via requestAnimationFrame
        
        let packets = []; // Todos os fragmentos criados
        let events = []; // Fila de eventos programados { time: X, action: 'move', packetId: Y, toRouteIndex: Z }
        
        // Rota para os pacotes
        const route = [
            'sourceB', // 0
            'sourceT', // 1
            'link1',   // 2
            'nodeBR',  // 3
            'nodeBB',  // 4
            'nodeBT',  // 5
            'link2',   // 6
            'nodeCR',  // 7
            'nodeCB',  // 8
            'nodeCT',  // 9
            'link3',   // 10
            'destinationR', // 11
            'destinationB'  // 12
        ];
        
        // Constantes da rede (KB/s, ms)
        const LINK_BANDWIDTH_KBS = 4; // KB por segundo
        const FRAGMENT_SIZE_KB = 1; // Cada "packet" visual é 1KB
        const PROPAGATION_DELAY_PER_LINK_SEC = 0.5; // 0.5 segundos por link, se selecionado
        
        // Calcula o tempo de transmissão de um fragmento (1KB) em um link
        const TRANSMISSION_TIME_PER_FRAGMENT = FRAGMENT_SIZE_KB / LINK_BANDWIDTH_KBS; // Segundos por fragmento
        
        // Velocidade base da simulação para animação (em ms por "unidade de tempo")
        const BASE_ANIMATION_UNIT_MS = 100; // Representa 0.25 segundos de tempo de simulação
        let animationScaleFactor = 1; // Ajustado pelo slider de velocidade
        
        // Função para criar pacotes (fragmentos de 1KB)
        function createPackets() {
            packets = [];
            events = [];
            
            const msgSize = parseInt(messageSize.value);
            const pktSize = parseInt(packetSize.value);
            
            const fullPackets = Math.floor(msgSize / pktSize);
            const remainderSize = msgSize % pktSize;
            
            let currentFragmentId = 0;
            let currentPackageId = 0;
            
            // Criando fragmentos completos
            for (let i = 0; i < fullPackets; i++) {
                for (let j = 0; j < pktSize; j++) {
                    packets.push({
                        id: currentFragmentId++,
                        packageId: currentPackageId,
                        routeIndex: 0, // Inicia em 'sourceB'
                        arrivalTime: 0 // Tempo em que o fragmento estará pronto para o próximo passo
                    });
                }
                currentPackageId++;
            }
            
            // Adicionando fragmentos restantes, se houver
            if (remainderSize > 0) {
                for (let j = 0; j < remainderSize; j++) {
                    packets.push({
                        id: currentFragmentId++,
                        packageId: currentPackageId,
                        routeIndex: 0,
                        arrivalTime: 0
                    });
                }
            }
            
            // Inicializa a fila de eventos: todos os fragmentos começam em sourceB no tempo 0
            packets.forEach(packet => {
                events.push({
                    time: 0,
                    type: 'placePacket',
                    packetId: packet.id,
                    location: 'sourceB'
                });
            });
            
            // Ordenar eventos por tempo
            events.sort((a, b) => a.time - b.time);
            
            renderPackets();
        }
        
        // Renderizar os pacotes nos buffers
        function renderPackets() {
            // Limpar todos os buffers
            Object.values(buffers).forEach(buffer => {
                const existingPackets = buffer.querySelectorAll('.packet');
                existingPackets.forEach(p => p.remove());
            });
            
            // Agrupar pacotes por buffer para posicionamento correto
            const packetsByLocation = {};
            packets.forEach(packet => {
                const currentBufferName = route[packet.routeIndex];
                if (!currentBufferName.startsWith('link')) { // Não renderiza pacotes em trânsito no link
                    if (!packetsByLocation[currentBufferName]) {
                        packetsByLocation[currentBufferName] = [];
                    }
                    packetsByLocation[currentBufferName].push(packet);
                }
            });
        
            // Renderizar pacotes em seus buffers atuais
            for (const bufferName in packetsByLocation) {
                const bufferElement = buffers[bufferName];
                // Ordenar para que os pacotes mais antigos fiquem na base do buffer
                packetsByLocation[bufferName].sort((a, b) => a.id - b.id); 
                
                packetsByLocation[bufferName].forEach((packet, index) => {
                    const packetElement = document.createElement('div');
                    packetElement.className = 'packet';
                    packetElement.id = `packet-${packet.id}`;
                    packetElement.textContent = `1KB`;
                    
                    // Definir cor baseada no pacote pai
                    const colorHue = (packet.packageId * 30) % 360;
                    packetElement.style.backgroundColor = `hsl(${colorHue}, 100%, 70%)`;
                    
                    const top = 10 + index * 14; // 14px = altura do pacote + margem
                    packetElement.style.top = `${top}px`;
                    bufferElement.appendChild(packetElement);
                });
            }
        }
        
        // Função principal de simulação baseada em eventos
        function simulateStep() {
            if (!simulationRunning || simulationPaused) return;
        
            let eventProcessed = false;
            const targetTime = simulationTime + (animationScaleFactor * 0.01); // Avança um pouco no tempo
        
            // Processar eventos que já deveriam ter ocorrido até o targetTime
            while (events.length > 0 && events[0].time <= targetTime) {
                const event = events.shift();
                
                const packet = packets.find(p => p.id === event.packetId);
                if (!packet) continue; // Pacote pode já ter sido removido (chegou ao destino)
        
                // Atualiza o tempo de simulação para o tempo do evento
                simulationTime = event.time;
        
                if (event.type === 'movePacket') {
                    packet.routeIndex = event.toRouteIndex;
                    // Se o pacote chegou ao destino final, removemos ele da lista de pacotes ativos
                    if (packet.routeIndex >= route.length -1 && route[packet.routeIndex] === 'destinationB') {
                        // Encontrar e remover o pacote da lista 'packets'
                        const index = packets.findIndex(p => p.id === packet.id);
                        if (index > -1) {
                            packets.splice(index, 1);
                        }
                    }
                } else if (event.type === 'scheduleNextMove') {
                    scheduleNextMove(packet);
                }
                eventProcessed = true;
            }
        
            timerDisplay.textContent = `TEMPO DECORRIDO: ${simulationTime.toFixed(2)}`;
            renderPackets(); // Atualiza a visualização após processar eventos
        
            const allPacketsDelivered = packets.length === 0;
            if (allPacketsDelivered) {
                stopSimulation();
                return;
            }
        
            // Agendar o próximo frame da animação
            animationFrameId = requestAnimationFrame(simulateStep);
        }
        
        // Agendar o próximo movimento para um pacote
        function scheduleNextMove(packet) {
            const currentRouteIndex = packet.routeIndex;
            const nextRouteIndex = currentRouteIndex + 1;
        
            if (nextRouteIndex >= route.length) {
                // Pacote chegou ao destino final, não há mais movimentos a agendar
                return;
            }
        
            const nextBufferName = route[nextRouteIndex];
            const currentBufferName = route[currentRouteIndex];
        
            let timeToNextStep = 0; // Tempo em segundos para o próximo passo
        
            // Lógica de tempo para cada transição
            if (currentBufferName.startsWith('source') && nextBufferName === 'link1') {
                // De sourceT para link1: tempo de transmissão
                timeToNextStep = TRANSMISSION_TIME_PER_FRAGMENT;
                if (delayL1.checked) timeToNextStep += PROPAGATION_DELAY_PER_LINK_SEC;
            } else if (currentBufferName.startsWith('nodeB') && nextBufferName === 'link2') {
                // De nodeBT para link2: tempo de transmissão
                timeToNextStep = TRANSMISSION_TIME_PER_FRAGMENT;
                if (delayL2.checked) timeToNextStep += PROPAGATION_DELAY_PER_LINK_SEC;
            } else if (currentBufferName.startsWith('nodeC') && nextBufferName === 'link3') {
                // De nodeCT para link3: tempo de transmissão
                timeToNextStep = TRANSMISSION_TIME_PER_FRAGMENT;
                if (delayL3.checked) timeToNextStep += PROPAGATION_DELAY_PER_LINK_SEC;
            } else if (currentBufferName.startsWith('link')) {
                // De um link para um buffer (após tempo de transmissão/propagação do link)
                // O tempo já foi contabilizado quando entrou no link, agora é só mover
                timeToNextStep = 0; // Transfere instantaneamente do "fim" do link para o buffer
            } else {
                // De um buffer interno (B, R) para outro buffer (T, R, B)
                // Considerar 0s para processamento/armazenamento em buffers internos
                timeToNextStep = 0;
            }
        
            const nextPacketArrivalTime = Math.max(packet.arrivalTime + timeToNextStep, simulationTime);
        
            // Agendar o movimento real do pacote
            events.push({
                time: nextPacketArrivalTime,
                type: 'movePacket',
                packetId: packet.id,
                toRouteIndex: nextRouteIndex
            });
        
            // Se o próximo estágio for um buffer, precisamos agendar o próximo movimento dele
            // O pacote pode ficar no buffer até que possa ser transmitido
            if (!nextBufferName.startsWith('link') && nextRouteIndex < route.length -1) {
                // Para o próximo movimento, o pacote sai do buffer assim que o anterior sair do buffer de transmissão e liberar espaço no link
                // Isso é tratado pela lógica de "agendar próximos eventos" no loop principal
                events.push({
                    time: nextPacketArrivalTime, // No mesmo instante que chegou, se puder sair
                    type: 'scheduleNextMove',
                    packetId: packet.id
                });
            }
        
            // Reordenar a fila de eventos para garantir que o próximo evento seja processado no momento correto
            events.sort((a, b) => a.time - b.time);
        }
        
        // Iniciar a simulação
        function startSimulation() {
            if (simulationRunning) return;
            
            // Resetar e inicializar
            simulationRunning = true;
            simulationPaused = false;
            simulationTime = 0;
            timerDisplay.textContent = `TEMPO DECORRIDO: 0.00`;
            
            updateButtonStates();
            
            createPackets(); // Popula 'packets' e 'events'
        
            // Iniciar o loop de simulação baseado em requestAnimationFrame
            animationFrameId = requestAnimationFrame(simulateStep);
        }
        
        // Pausar a simulação
        function pauseSimulation() {
            if (!simulationRunning || simulationPaused) return;
            
            simulationPaused = true;
            cancelAnimationFrame(animationFrameId); // Para o loop de animação
            updateButtonStates();
        }
        
        // Retomar a simulação
        function resumeSimulation() {
            if (!simulationRunning || !simulationPaused) return;
            
            simulationPaused = false;
            animationFrameId = requestAnimationFrame(simulateStep); // Continua o loop de animação
            updateButtonStates();
        }
        
        // Parar a simulação
        function stopSimulation() {
            if (!simulationRunning) return;
            
            cancelAnimationFrame(animationFrameId); // Para o loop de animação
            simulationRunning = false;
            simulationPaused = false;
            
            // Limpar pacotes da tela e re-renderizar vazio
            packets = [];
            events = [];
            renderPackets();
            
            timerDisplay.textContent = `TEMPO DECORRIDO: ${simulationTime.toFixed(2)}`;
            updateButtonStates();
        }
        
        // Atualizar estados dos botões
        function updateButtonStates() {
            startBtn.disabled = simulationRunning;
            pauseBtn.disabled = !simulationRunning || simulationPaused;
            resumeBtn.disabled = !simulationRunning || !simulationPaused;
            stopBtn.disabled = !simulationRunning;
            
            // Desabilitar configurações durante a simulação
            messageSize.disabled = simulationRunning;
            packetSize.disabled = simulationRunning;
            delayL1.disabled = simulationRunning;
            delayL2.disabled = simulationRunning;
            delayL3.disabled = simulationRunning;
        }
        
        // Event listeners
        startBtn.addEventListener('click', startSimulation);
        pauseBtn.addEventListener('click', pauseSimulation);
        resumeBtn.addEventListener('click', resumeSimulation);
        stopBtn.addEventListener('click', stopSimulation);
        
        simulationSpeed.addEventListener('input', () => {
            const speedFactor = parseInt(simulationSpeed.value);
            // Invertemos a escala para que um valor maior signifique mais rápido
            animationScaleFactor = 11 - speedFactor; // 1 (mais rápido) a 10 (mais lento)
            // A animação agora avança mais ou menos tempo de simulação por frame real
        });
        
        // Inicialização
        updateButtonStates();
    </script>
</body>
</html>