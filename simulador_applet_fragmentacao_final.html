<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Fragmentação de Pacotes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 950px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f8f8;
        }
        
        .controls {
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .delay-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        label {
            margin-right: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        button {
            padding: 6px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .timer {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            border: 1px solid #ddd;
        }
        
        .network-container {
            background-color: #ffecec;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            height: 400px;
            border: 2px solid #ff9999;
            overflow: hidden;
        }
        
        .nodes {
            display: flex;
            justify-content: space-between;
            height: 100%;
            position: relative;
        }
        
        .node {
            width: 100px;
            height: 330px;
            background-color: #ffffff;
            border: 2px solid #333;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .node-label {
            position: absolute;
            bottom: -25px;
            text-align: center;
            font-weight: bold;
        }
        
        .links {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            z-index: 0;
        }
        
        .link {
            height: 10px;
            background-color: #99ccff;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            border: 1px solid #0066cc;
        }
        
        #link1 {
            left: 102px;
            width: calc(25% - 102px);
        }
        
        #link2 {
            left: 25%;
            width: 50%;
        }
        
        #link3 {
            right: 102px;
            width: calc(25% - 102px);
        }
        
        .buffer {
            width: 80px;
            height: 300px;
            margin: 5px;
            border: 1px dashed #333;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }
        
        .buffer-label {
            position: absolute;
            top: -20px;
            font-weight: bold;
            color: blue;
        }
        
        .packet {
            width: 60px;
            height: 10px;
            background-color: yellow;
            border: 1px solid #333;
            margin: 2px;
            font-size: 8px;
            text-align: center;
            position: absolute;
            transition: all 0.05s linear; /* Transição mais suave para movimento */
        }
        
        .simulation-speed {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 40px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        
        .legend-color {
            width: 20px;
            height: 10px;
            border: 1px solid black;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .checkbox-container input {
            margin: 0;
        }
    </style>
</head>
<body>
    <h1>Simulador de Fragmentação de Pacotes em Redes</h1>
    
    <div class="controls">
        <div class="control-group">
            <label for="messageSize">Tamanho da Mensagem (KBs):</label>
            <select id="messageSize">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4">4</option>
                <option value="8">8</option>
                <option value="10" selected>10</option>
                <option value="16">16</option>
                <option value="20">20</option>
                <option value="32">32</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="packetSize">Tamanho do Pacote (KBs):</label>
            <select id="packetSize">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4" selected>4</option>
                <option value="8">8</option>
            </select>
        </div>
        
        <p>* Para mensagens não divisíveis, serão criados fragmentos de 1KB</p>
    </div>
    
    <div class="controls">
        <div class="delay-controls">
            <label>Atraso de Propagação (segundos, se marcado):</label>
            <div class="checkbox-container">
                <input type="checkbox" id="addDelayL1">
                <label for="addDelayL1">L1 (1s)</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="addDelayL2">
                <label for="addDelayL2">L2 (1s)</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="addDelayL3">
                <label for="addDelayL3">L3 (1s)</label>
            </div>
        </div>
        
        <div class="simulation-speed">
            <label>Velocidade da Simulação:</label>
            <input type="range" id="simulationSpeed" min="1" max="10" value="5">
            <span>slow</span>
            <span>fast</span>
        </div>
    </div>
    
    <div class="controls">
        <button id="startBtn">Iniciar</button>
        <button id="pauseBtn" disabled>Pausar</button>
        <button id="resumeBtn" disabled>Continuar</button>
        <button id="stopBtn" disabled>Parar</button>
    </div>
    
    <div class="timer" id="timer">TEMPO DECORRIDO: 0.00</div>
    
    <div class="network-container">
        <div class="links">
            <div class="link" id="link1"></div>
            <div class="link" id="link2"></div>
            <div class="link" id="link3"></div>
        </div>
        
        <div class="nodes">
            <div class="node" id="source">
                <div class="buffer" id="sourceB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="sourceT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">Source</div>
            </div>
            
            <div class="node" id="nodeB">
                <div class="buffer" id="nodeBR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="nodeBB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="nodeBT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">B</div>
            </div>
            
            <div class="node" id="nodeC">
                <div class="buffer" id="nodeCR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="nodeCB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="buffer" id="nodeCT">
                    <span class="buffer-label">T</span>
                </div>
                <div class="node-label">C</div>
            </div>
            
            <div class="node" id="destination">
                <div class="buffer" id="destinationR">
                    <span class="buffer-label">R</span>
                </div>
                <div class="buffer" id="destinationB">
                    <span class="buffer-label">B</span>
                </div>
                <div class="node-label">Destination</div>
            </div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: yellow;"></div>
            <span>Pacote de 1KB</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #99ccff;"></div>
            <span>Link (4 KB/s)</span>
        </div>
        <div class="legend-item">
            <span>R: Buffer de recepção</span>
        </div>
        <div class="legend-item">
            <span>B: Buffer interno</span>
        </div>
        <div class="legend-item">
            <span>T: Buffer de transmissão</span>
        </div>
    </div>
    
    <script>
        // Elementos da interface
        const messageSize = document.getElementById('messageSize');
        const packetSize = document.getElementById('packetSize');
        const simulationSpeed = document.getElementById('simulationSpeed');
        const addDelayL1 = document.getElementById('addDelayL1');
        const addDelayL2 = document.getElementById('addDelayL2');
        const addDelayL3 = document.getElementById('addDelayL3');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerDisplay = document.getElementById('timer');
        
        // Buffers
        const buffers = {
            sourceB: document.getElementById('sourceB'),
            sourceT: document.getElementById('sourceT'),
            nodeBR: document.getElementById('nodeBR'),
            nodeBB: document.getElementById('nodeBB'),
            nodeBT: document.getElementById('nodeBT'),
            nodeCR: document.getElementById('nodeCR'),
            nodeCB: document.getElementById('nodeCB'),
            nodeCT: document.getElementById('nodeCT'),
            destinationR: document.getElementById('destinationR'),
            destinationB: document.getElementById('destinationB')
        };
        
        // Links
        const links = {
            link1: document.getElementById('link1'),
            link2: document.getElementById('link2'),
            link3: document.getElementById('link3')
        };

        // Variáveis de controle da simulação
        let simulationRunning = false;
        let simulationPaused = false;
        let simulationTime = 0;
        let timerInterval;
        let packets = [];
        let currentPacketId = 0;
        
        // Rota para os pacotes
        const route = [
            'sourceB',
            'sourceT',
            'link1',
            'nodeBR',
            'nodeBB',
            'nodeBT',
            'link2',
            'nodeCR',
            'nodeCB',
            'nodeCT',
            'link3',
            'destinationR',
            'destinationB'
        ];
        
        // Velocidade do link em KB/s
        const LINK_SPEED_KB_PER_S = 4; // 4 KB por segundo

        // Tempo para transmitir 1KB em um link (em segundos)
        const TIME_PER_1KB_TRANSMISSION = 1 / LINK_SPEED_KB_PER_S; // 0.25 segundos por 1KB
        
        // Atraso de propagação padrão (0 por padrão, 1s se marcado)
        const DEFAULT_PROPAGATION_DELAY_PER_LINK = 1; // 1 segundo se ativado
        
        // Função para criar pacotes
        function createPackets() {
            packets = [];
            currentPacketId = 0;
            
            const msgSize = parseInt(messageSize.value);
            const pktSize = parseInt(packetSize.value);
            
            const fullPackets = Math.floor(msgSize / pktSize);
            const remainderSize = msgSize % pktSize;
            
            for (let i = 0; i < fullPackets; i++) {
                for (let j = 0; j < pktSize; j++) {
                    packets.push({
                        id: currentPacketId++,
                        size: 1, // 1KB por fragmento
                        packageId: i,
                        routeIndex: 0,
                        inTransit: false,
                        arrivalTime: 0,
                        propagationStart: 0,
                        isBeingProcessed: false // Indica se está sendo processado neste tick
                    });
                }
            }
            
            if (remainderSize > 0) {
                for (let j = 0; j < remainderSize; j++) {
                    packets.push({
                        id: currentPacketId++,
                        size: 1,
                        packageId: fullPackets,
                        routeIndex: 0,
                        inTransit: false,
                        arrivalTime: 0,
                        propagationStart: 0,
                        isBeingProcessed: false
                    });
                }
            }
            
            // Inicializa todos os pacotes no sourceB
            packets.forEach(p => p.routeIndex = route.indexOf('sourceB'));
            renderPackets();
        }
        
        // Renderizar os pacotes nos buffers e links
        function renderPackets() {
            // Remove todos os pacotes existentes dos buffers e links
            Object.values(buffers).forEach(buffer => {
                const existingPackets = buffer.querySelectorAll('.packet');
                existingPackets.forEach(p => p.remove());
            });
            Object.values(links).forEach(link => {
                const existingPackets = link.querySelectorAll('.packet');
                existingPackets.forEach(p => p.remove());
            });
            
            packets.forEach(packet => {
                // Se o pacote já chegou ao destino final (destinationB) e está lá, ou se já foi "entregue"
                if (packet.routeIndex >= route.length) { 
                    return; // Não renderiza pacotes que já completaram a rota
                }

                const currentStageName = route[packet.routeIndex];
                let parentElement = null;

                if (currentStageName.startsWith('link')) {
                    parentElement = links[currentStageName];
                } else {
                    parentElement = buffers[currentStageName];
                }
                
                if (parentElement) {
                    let packetElement = document.getElementById(`packet-${packet.id}`);
                    if (!packetElement) { // Cria o elemento se ele não existe
                        packetElement = document.createElement('div');
                        packetElement.className = 'packet';
                        packetElement.id = `packet-${packet.id}`;
                        packetElement.textContent = `1KB`;
                        const colorHue = (packet.packageId * 30) % 360;
                        packetElement.style.backgroundColor = `hsl(${colorHue}, 100%, 70%)`;
                        parentElement.appendChild(packetElement);
                    } else { // Caso contrário, apenas o move para o novo pai (se mudou)
                         if (packetElement.parentElement !== parentElement) {
                            parentElement.appendChild(packetElement);
                         }
                    }
                    
                    // Lógica de posicionamento:
                    if (currentStageName.startsWith('link')) {
                        // Posicionamento no link
                        let linkProgress = 0;
                        if (packet.inTransit && packet.propagationStart > 0 && packet.arrivalTime > packet.propagationStart) {
                            // Calcula o progresso baseado no tempo decorrido no link
                            const timeInLink = simulationTime - packet.propagationStart;
                            const linkDuration = packet.arrivalTime - packet.propagationStart;
                            linkProgress = Math.min(1, Math.max(0, timeInLink / linkDuration));
                        }
                        // Move o pacote ao longo do link
                        packetElement.style.left = `${linkProgress * (parentElement.offsetWidth - packetElement.offsetWidth)}px`;
                        packetElement.style.top = '2px'; // Centralizado verticalmente no link
                    } else {
                        // Posicionamento no buffer
                        // Filtra apenas os pacotes que estão *realmente* no buffer atual e não estão em trânsito
                        const packetsInBuffer = packets.filter(p => 
                            p.routeIndex === packet.routeIndex && 
                            !p.inTransit // Apenas pacotes que não estão em trânsito (já chegaram ou estão aguardando)
                        ).sort((a, b) => a.id - b.id);
                        
                        const position = packetsInBuffer.indexOf(packet);
                        
                        // Se o pacote está em trânsito e o estágio anterior era um link,
                        // significa que ele está na borda de entrada do buffer, então renderiza na primeira posição.
                        // Caso contrário, usa a posição calculada no buffer.
                        if (packet.inTransit && route.indexOf(currentStageName) > 0 && route[route.indexOf(currentStageName) - 1].startsWith('link')) {
                            packetElement.style.top = '10px'; 
                        } else if (position !== -1) {
                            const top = 10 + position * 14;
                            packetElement.style.top = `${top}px`;
                        } else {
                            // Se o pacote não está em trânsito, mas não foi encontrado em packetsInBuffer
                            // (pode ser um pacote que está sendo processado para saída do buffer),
                            // ele deve estar na primeira posição de saída.
                            packetElement.style.top = '10px'; 
                        }
                    }
                }
            });
        }
        
        // Processar a movimentação dos pacotes
        function processPacketMovement() {
            if (!simulationRunning || simulationPaused) return;
            
            // Verifica se TODOS os pacotes chegaram ao último estágio (destinationB)
            const allPacketsDelivered = packets.every(p => p.routeIndex >= route.length - 1);
            if (allPacketsDelivered && packets.length > 0) { // Garante que há pacotes para entregar e que a lista não está vazia
                stopSimulation();
                return;
            }
            
            const speedFactor = parseInt(simulationSpeed.value);
            const timeStep = 0.01 * (speedFactor / 5); 

            // Iterar sobre os pacotes do fim para o início para evitar que um pacote
            // seja processado múltiplas vezes dentro do mesmo tick (ex: mover sourceB -> sourceT -> link1 no mesmo tick)
            const packetsToProcess = [...packets].sort((a, b) => b.routeIndex - a.routeIndex); // Processa do fim para o início

            for (let i = 0; i < packetsToProcess.length; i++) {
                const packet = packetsToProcess[i];

                // Se o pacote já chegou ou está além do destino final, continue.
                if (packet.routeIndex >= route.length -1) { 
                    // Se o pacote está no destinationB, ele está entregue, não precisa processar mais.
                    continue; 
                }

                const currentStageName = route[packet.routeIndex];
                const nextStageName = route[packet.routeIndex + 1];

                // Lógica para Links
                if (currentStageName.startsWith('link')) {
                    const linkNumber = currentStageName.charAt(4);
                    const addPropagationDelay = document.getElementById(`addDelayL${linkNumber}`).checked;
                    const propagationDelay = addPropagationDelay ? DEFAULT_PROPAGATION_DELAY_PER_LINK : 0;

                    // Se o pacote está em trânsito no link
                    if (packet.inTransit) {
                        // Se o tempo atual da simulação for maior ou igual ao tempo de chegada esperado no próximo estágio
                        if (simulationTime >= packet.arrivalTime) {
                            packet.routeIndex++; // Move para o próximo estágio (buffer)
                            packet.inTransit = false; // Não está mais em trânsito no link
                            packet.isBeingProcessed = false; // Liberar para o próximo ciclo
                        }
                        // else: O pacote ainda está em trânsito, não faça nada aqui, ele será re-renderizado na posição atual.
                    } else { // O pacote não está em trânsito (acabou de entrar no link)
                        // Calcular o tempo total que o pacote levará para atravessar este link
                        let totalLinkTime = TIME_PER_1KB_TRANSMISSION + propagationDelay;
                        
                        packet.propagationStart = simulationTime; // Marca o início da propagação
                        packet.arrivalTime = simulationTime + totalLinkTime; // Tempo de chegada no próximo estágio
                        packet.inTransit = true; // Pacote agora está em trânsito no link
                    }
                } 
                // Lógica para Buffers (R, B, T)
                else {
                    // Buffers têm capacidade, links têm capacidade infinita para receber (o atraso é a limitação)
                    const nextBufferCapacity = nextStageName.startsWith('link') ? Infinity : 20; 
                    
                    // Contar quantos pacotes já estão no *próximo* buffer que não estão em trânsito *saindo* dele.
                    const packetsInNextBuffer = packets.filter(p => 
                        p.routeIndex === route.indexOf(nextStageName) && 
                        !p.inTransit // Considera apenas pacotes "parados" no próximo buffer
                    ).length;

                    // Condição para mover: O pacote não está em trânsito E o próximo estágio tem capacidade
                    if (!packet.inTransit && packetsInNextBuffer < nextBufferCapacity) {
                        // Se o estágio atual é um buffer de transmissão e o próximo é um link
                        if (currentStageName.endsWith('T') && nextStageName.startsWith('link')) {
                            // Verifica se o link já tem um pacote "inTransit" que ainda não terminou sua propagação.
                            // Isso simula que apenas um pacote pode estar em transmissão (ocupando a "largura de banda") por vez para um link.
                            const linkOccupied = packets.some(p => p.routeIndex === route.indexOf(nextStageName) && p.inTransit);
                            
                            if (!linkOccupied) { // Se o link não estiver ocupado, pode mover o pacote para o link
                                packet.routeIndex++; // Move para o link
                                // inTransit será definido como true na próxima iteração do link
                            }
                        } else {
                            // Movimento entre buffers (R -> B, B -> T, ou T -> R/B se não for link) é instantâneo
                            packet.routeIndex++;
                        }
                    }
                }
            }
            renderPackets(); // Chama renderizar após todos os movimentos do tick
        }
        
        // Iniciar a simulação
        function startSimulation() {
            if (simulationRunning) return;
            
            simulationRunning = true;
            simulationPaused = false;
            simulationTime = 0;
            timerDisplay.textContent = `TEMPO DECORRIDO: 0.00`;
            
            updateButtonStates();
            createPackets(); // Cria os pacotes e os renderiza inicialmente
            
            timerInterval = setInterval(() => {
                if (!simulationPaused) {
                    const speedFactor = parseInt(simulationSpeed.value);
                    simulationTime += 0.01 * (speedFactor / 5); 
                    timerDisplay.textContent = `TEMPO DECORRIDO: ${simulationTime.toFixed(2)}`;
                    
                    processPacketMovement(); // Processa e renderiza os movimentos a cada tick
                }
            }, 10);
        }
        
        // Pausar a simulação
        function pauseSimulation() {
            if (!simulationRunning || simulationPaused) return;
            
            simulationPaused = true;
            updateButtonStates();
        }
        
        // Retomar a simulação
        function resumeSimulation() {
            if (!simulationRunning || !simulationPaused) return;
            
            simulationPaused = false;
            updateButtonStates();
        }
        
        // Parar a simulação
        function stopSimulation() {
            if (!simulationRunning) return;
            
            clearInterval(timerInterval);
            simulationRunning = false;
            simulationPaused = false;
            
            // Remove todos os elementos visuais dos pacotes
            Object.values(buffers).forEach(buffer => {
                const existingPackets = buffer.querySelectorAll('.packet');
                existingPackets.forEach(p => p.remove());
            });
            Object.values(links).forEach(link => {
                const existingPackets = link.querySelectorAll('.packet');
                existingPackets.forEach(p => p.remove());
            });
            packets = []; // Limpa a lista de pacotes
            
            updateButtonStates();
        }
        
        // Atualizar estados dos botões
        function updateButtonStates() {
            startBtn.disabled = simulationRunning;
            pauseBtn.disabled = !simulationRunning || simulationPaused;
            resumeBtn.disabled = !simulationRunning || !simulationPaused;
            stopBtn.disabled = !simulationRunning;
            
            messageSize.disabled = simulationRunning;
            packetSize.disabled = simulationRunning;
            addDelayL1.disabled = simulationRunning;
            addDelayL2.disabled = simulationRunning;
            addDelayL3.disabled = simulationRunning;
        }
        
        // Event listeners
        startBtn.addEventListener('click', startSimulation);
        pauseBtn.addEventListener('click', pauseSimulation);
        resumeBtn.addEventListener('click', resumeSimulation);
        stopBtn.addEventListener('click', stopSimulation);
        
        simulationSpeed.addEventListener('input', () => {
            // A velocidade é aplicada no timeStep do timerInterval
        });
        
        // Inicialização
        updateButtonStates();
    </script>
</body>
</html>