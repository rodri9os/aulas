<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Fragmentação de Pacotes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 5px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .delay-control {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .timer {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #f06292;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .network {
            position: relative;
            background-color: #ffcdd2;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            min-height: 300px;
            overflow: hidden;
        }

        .nodes {
            display: flex;
            justify-content: space-between;
            margin-top: 150px;
            position: relative;
            padding: 0 30px;
        }

        .node {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80px;
            text-align: center;
            z-index: 3;
            position: relative;
        }

        .node-name {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 16px;
            background-color: #3f51b5;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
        }

        .buffers {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .buffer {
            width: 60px;
            height: 150px; /* Altura ajustada para permitir mais pacotes visíveis (temporário) */
            border: 2px solid black;
            background-color: white;
            position: relative;
            overflow: hidden; /* Permite que os pacotes se empilhem */
        }

        .buffer-label {
            position: absolute;
            top: 0;
            left: 0;
            font-size: 12px;
            font-weight: bold;
            padding: 2px;
            background-color: rgba(255, 255, 255, 0.7);
        }

        .link {
            position: absolute;
            height: 8px;
            background-color: #90caf9;
            top: 150px;
            border-radius: 4px;
            z-index: 1;
        }

        #link1 {
            left: 14%;
            width: 18%;
        }

        #link2 {
            left: 41%;
            width: 18%;
        }

        #link3 {
            left: 68%;
            width: 18%;
        }

        .link-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
            background-color: white;
            padding: 2px 6px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .packet {
            width: 56px; /* Largura ajustada para caber no buffer */
            height: 10px;
            background-color: yellow;
            border: 1px solid black;
            position: absolute;
            left: 2px;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: bottom 0.2s ease-out; /* Transição para empilhamento */
        }

        .packet-in-transit {
            position: absolute;
            width: 20px;
            height: 10px;
            background-color: yellow;
            border: 1px solid black;
            z-index: 2;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: none; /* Sem transição de posição para a animação do link */
        }

        .legend {
            margin-top: 20px;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 20px;
            height: 10px;
            margin-right: 10px;
            border: 1px solid black;
        }

        .legend-text {
            flex: 1;
        }

        .info-panel {
            background-color: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .stats-panel {
            background-color: #e8f5e9;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        /* Cores diferentes para pacotes de diferentes grupos */
        .packet-group-0 { background-color: #ffeb3b; } /* Amarelo */
        .packet-group-1 { background-color: #ffa726; } /* Laranja */
        .packet-group-2 { background-color: #66bb6a; } /* Verde */
        .packet-group-3 { background-color: #29b6f6; } /* Azul claro */
        .packet-group-4 { background-color: #ab47bc; } /* Roxo */
        .packet-group-5 { background-color: #ec407a; } /* Rosa */
        .packet-group-6 { background-color: #5c6bc0; } /* Azul escuro */
        .packet-group-7 { background-color: #26a69a; } /* Verde-azulado */
        .packet-group-8 { background-color: #d4e157; } /* Verde limão */
        .packet-group-9 { background-color: #8d6e63; } /* Marrom */

        /* Estilo para fragmentos */
        .fragment::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            height: 5px;
            background-color: red;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simulador de Fragmentação de Pacotes</h1>

        <div class="info-panel">
            <h3>Informações sobre o Simulador</h3>
            <p>Este simulador demonstra o processo de fragmentação de pacotes em uma rede. Cada retângulo colorido representa 1 kB de dados.</p>
            <p><strong>Conceito importante:</strong> Quando o tamanho da mensagem não é divisível pelo tamanho máximo do pacote, ocorre fragmentação. Cada fragmento, mesmo que menor, gasta o mesmo tempo de transmissão que um pacote completo, simulando o "payload" adicional.</p>
            <p>Os pacotes da mesma mensagem têm a mesma cor para facilitar a visualização.</p>
        </div>

        <div class="stats-panel">
            <h3>Estatísticas da Simulação</h3>
            <div id="packetStats">
                <p>Tamanho da mensagem: <span id="statMessageSize">0</span> kB</p>
                <p>Tamanho máximo de pacote: <span id="statPacketSize">0</span> kB</p>
                <p>Número de pacotes: <span id="statNumPackets">0</span></p>
                <p>Número de fragmentos: <span id="statFragments">0</span></p>
                <p>Bytes de overhead: <span id="statOverhead">0</span> kB</p>
                <p>Eficiência: <span id="statEfficiency">0</span>%</p>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="messageSize">Tamanho da Mensagem (kB):</label>
                <input type="number" id="messageSize" min="1" max="100" value="10">
            </div>

            <div class="control-group">
                <label for="packetSize">Tamanho Máximo do Pacote (kB):</label>
                <input type="number" id="packetSize" min="1" max="10" value="4">
            </div>

            <div class="delay-control">
                <span>Atraso de Propagação:</span>
                <div>
                    <input type="checkbox" id="delay1"> <label for="delay1">L1</label>
                    <input type="checkbox" id="delay2"> <label for="delay2">L2</label>
                    <input type="checkbox" id="delay3"> <label for="delay3">L3</label>
                </div>
            </div>

            <div class="speed-control">
                <span>Velocidade:</span>
                <div>
                    <input type="radio" id="speedSlow" name="speed" value="slow" checked>
                    <label for="speedSlow">Lenta</label>
                    <input type="radio" id="speedNormal" name="speed" value="normal">
                    <label for="speedNormal">Normal</label>
                    <input type="radio" id="speedFast" name="speed" value="fast">
                    <label for="speedFast">Rápida</label>
                </div>
            </div>
        </div>
        <div class="buttons">
            <button id="startBtn">Iniciar</button>
            <button id="pauseBtn" disabled>Pausar</button>
            <button id="resumeBtn" disabled>Retomar</button>
            <button id="stopBtn" disabled>Parar</button>
        </div>

        <div class="timer">TEMPO DECORRIDO: 0.00</div>

        <div class="network">
            <div class="links">
                <div class="link" id="link1">
                    <div class="link-label">L1</div>
                </div>
                <div class="link" id="link2">
                    <div class="link-label">L2</div>
                </div>
                <div class="link" id="link3">
                    <div class="link-label">L3</div>
                </div>
            </div>

            <div class="nodes">
                <div class="node">
                    <div class="node-name">Fonte</div>
                    <div class="buffers">
                        <div class="buffer" id="sourceB">
                            <div class="buffer-label">B</div>
                        </div>
                        <div class="buffer" id="sourceT">
                            <div class="buffer-label">T</div>
                        </div>
                    </div>
                </div>

                <div class="node">
                    <div class="node-name">B</div>
                    <div class="buffers">
                        <div class="buffer" id="nodeB_R">
                            <div class="buffer-label">R</div>
                        </div>
                        <div class="buffer" id="nodeB_B">
                            <div class="buffer-label">B</div>
                        </div>
                        <div class="buffer" id="nodeB_T">
                            <div class="buffer-label">T</div>
                        </div>
                    </div>
                </div>

                <div class="node">
                    <div class="node-name">C</div>
                    <div class="buffers">
                        <div class="buffer" id="nodeC_R">
                            <div class="buffer-label">R</div>
                        </div>
                        <div class="buffer" id="nodeC_B">
                            <div class="buffer-label">B</div>
                        </div>
                        <div class="buffer" id="nodeC_T">
                            <div class="buffer-label">T</div>
                        </div>
                    </div>
                </div>

                <div class="node">
                    <div class="node-name">Destino</div>
                    <div class="buffers">
                        <div class="buffer" id="destR">
                            <div class="buffer-label">R</div>
                        </div>
                        <div class="buffer" id="destB">
                            <div class="buffer-label">B</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="legend">
            <h3>Legenda</h3>
            <div class="legend-item">
                <div class="legend-color" style="background-color: yellow;"></div>
                <div class="legend-text">Cada retângulo representa um fragmento de dados. Pacotes da mesma mensagem têm a mesma cor.</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: yellow; position: relative;">
                    <div style="position: absolute; top: 0; right: 0; width: 5px; height: 5px; background-color: red; border-radius: 50%;"></div>
                </div>
                <div class="legend-text">Fragmentos (partes de pacotes que não preenchem o tamanho máximo do pacote).</div>
            </div>
            <div class="legend-item">
                <div style="font-weight: bold; margin-right: 10px;">R:</div>
                <div class="legend-text">Buffer de recepção</div>
            </div>
            <div class="legend-item">
                <div style="font-weight: bold; margin-right: 10px;">B:</div>
                <div class="legend-text">Buffer interno</div>
            </div>
            <div class="legend-item">
                <div style="font-weight: bold; margin-right: 10px;">T:</div>
                <div class="legend-text">Buffer de transmissão</div>
            </div>
        </div>
    </div>

    <script>
        // Variáveis globais
        let timer; // Variável para o setInterval do timer
        let elapsedTime = 0;
        let isRunning = false;
        let packets = []; // Lista de todos os fragmentos criados inicialmente (referências a objetos DOM)
        let packetsInTransit = []; // Fragmentos atualmente nos links (referências a objetos DOM de trânsito)
        let animationSpeed = 1000; // Velocidade em ms (padrão: lento, tempo para mover um fragmento entre buffers ou iniciar/finalizar um link)
        let delays = { L1: false, L2: false, L3: false };
        let simulationInterval; // O intervalo principal da simulação que move os pacotes
        let checkEndTimeoutId = null; // Para controlar o setTimeout da verificação final

        // Captura elementos do DOM
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerElement = document.querySelector('.timer');

        // Event listeners para botões
        startBtn.addEventListener('click', startSimulation);
        pauseBtn.addEventListener('click', pauseSimulation);
        resumeBtn.addEventListener('click', resumeSimulation);
        stopBtn.addEventListener('click', stopSimulation);

        // Event listeners para controle de velocidade
        document.getElementById('speedSlow').addEventListener('change', updateSpeed);
        document.getElementById('speedNormal').addEventListener('change', updateSpeed);
        document.getElementById('speedFast').addEventListener('change', updateSpeed);

        // Event listeners para delays
        document.getElementById('delay1').addEventListener('change', updateDelays);
        document.getElementById('delay2').addEventListener('change', updateDelays);
        document.getElementById('delay3').addEventListener('change', updateDelays);

        // Limite de pacotes por buffer para visualização
        const BUFFER_CAPACITY = 15; // TEMPORARIAMENTE AUMENTADO PARA TESTE

        // Atualiza velocidade baseada na seleção do usuário
        function updateSpeed() {
            if (document.getElementById('speedSlow').checked) {
                animationSpeed = 1000;
            } else if (document.getElementById('speedNormal').checked) {
                animationSpeed = 500;
            } else if (document.getElementById('speedFast').checked) {
                animationSpeed = 200;
            }
            if (isRunning) { // Ajusta a velocidade da simulação se já estiver rodando
                clearInterval(simulationInterval);
                simulationInterval = setInterval(moveNextPacket, animationSpeed);
            }
        }

        // Atualiza configurações de delay
        function updateDelays() {
            delays.L1 = document.getElementById('delay1').checked;
            delays.L2 = document.getElementById('delay2').checked;
            delays.L3 = document.getElementById('delay3').checked;
        }

        // Calcula e atualiza estatísticas
        function updateStats(messageSize, packetSize) {
            const numLogicalPackets = Math.ceil(messageSize / packetSize);
            const totalDataBytes = messageSize * 1024;
            const overheadPerPacket = 20; // bytes
            const totalOverheadBytes = numLogicalPackets * overheadPerPacket;
            const totalTransmittedBytes = totalDataBytes + totalOverheadBytes;

            const fragments = (messageSize % packetSize !== 0) ? 1 : 0; // Se houver resto, significa um fragmento no último pacote lógico

            const efficiency = (totalTransmittedBytes > 0) ? (totalDataBytes / totalTransmittedBytes) * 100 : 0;

            document.getElementById('statMessageSize').textContent = messageSize;
            document.getElementById('statPacketSize').textContent = packetSize;
            document.getElementById('statNumPackets').textContent = numLogicalPackets;
            document.getElementById('statFragments').textContent = fragments;
            document.getElementById('statOverhead').textContent = (totalOverheadBytes / 1024).toFixed(2);
            document.getElementById('statEfficiency').textContent = efficiency.toFixed(2);
        }

        // Inicia a simulação
        function startSimulation() {
            // Reset de qualquer simulação anterior
            resetSimulation();

            // Captura valores dos inputs
            const messageSize = parseInt(document.getElementById('messageSize').value);
            const packetSize = parseInt(document.getElementById('packetSize').value);

            // Validação dos inputs
            if (isNaN(messageSize) || isNaN(packetSize) || messageSize <= 0 || packetSize <= 0) {
                alert("Por favor, insira valores válidos e positivos para o tamanho da mensagem e do pacote.");
                return;
            }

            // Atualiza estatísticas
            updateStats(messageSize, packetSize);

            // Cria os fragmentos (cada um representando 1kB)
            let currentMessageBytes = messageSize;
            let packetGroupCounter = 0; // Para rastrear a qual "pacote lógico" o fragmento pertence
            let fragmentCounter = 0; // Contador global de fragmentos para ID única

            while (currentMessageBytes > 0) {
                const bytesInThisLogicalPacket = Math.min(packetSize, currentMessageBytes);
                currentMessageBytes -= bytesInThisLogicalPacket;

                for (let j = 0; j < bytesInThisLogicalPacket; j++) {
                    const packet = document.createElement('div');
                    packet.className = `packet packet-group-${packetGroupCounter % 10}`;

                    const isLastFragmentOfLogicalPacket = (j === bytesInThisLogicalPacket - 1);
                    // Adiciona a classe 'fragment' se for o último fragmento do pacote lógico e o pacote não for do tamanho máximo
                    if (isLastFragmentOfLogicalPacket && bytesInThisLogicalPacket < packetSize) {
                        packet.classList.add('fragment');
                    }

                    packet.dataset.id = `f${fragmentCounter++}`; // ID única para cada fragmento
                    packet.dataset.packetGroup = packetGroupCounter;
                    packet.dataset.size = 1; // Cada fragmento representa 1kB
                    packet.dataset.location = 'sourceB';
                    packet.dataset.status = 'waiting'; // Adiciona um status para cada fragmento
                    packet.textContent = `P${packetGroupCounter + 1}f${j + 1}`; // Ex: P1f1 (Pacote 1, fragmento 1)
                    packet.style.height = '10px';
                    document.getElementById('sourceB').appendChild(packet);
                    packets.push(packet); // Adiciona à lista global de todos os fragmentos criados (objetos DOM)
                }
                packetGroupCounter++;
            }

            // Inicializa a posição dos pacotes no buffer da fonte
            reorganizePacketsInBuffer('sourceB');

            // Atualiza estados dos botões
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            resumeBtn.disabled = true;

            // Inicia o timer
            isRunning = true;
            startTimer();

            // Inicia a animação da simulação
            simulationInterval = setInterval(moveNextPacket, animationSpeed);
            console.log("Simulação iniciada. Timer ID:", timer, "Simulation Interval ID:", simulationInterval);
        }

        // Pausa a simulação
        function pauseSimulation() {
            console.log("Pausando simulação...");
            isRunning = false;
            clearInterval(timer); // Para o timer
            clearInterval(simulationInterval); // Para o loop principal de movimento
            if (checkEndTimeoutId) clearTimeout(checkEndTimeoutId); // Limpa qualquer timeout de verificação pendente
            pauseBtn.disabled = true;
            resumeBtn.disabled = false;
            console.log("Simulação pausada. Timer parado.");
        }

        // Retoma a simulação
        function resumeSimulation() {
            console.log("Retomando simulação...");
            isRunning = true;
            startTimer(); // Reinicia o timer
            updateSpeed(); // Isso recria o simulationInterval com a velocidade atual
            resumeBtn.disabled = true;
            pauseBtn.disabled = false;
            console.log("Simulação retomada.");
        }

        // Para a simulação COMPLETAMENTE (manual ou automática)
        function stopSimulation() {
            if (!isRunning) {
                console.log("stopSimulation chamada, mas já não está rodando (isRunning é false).");
                return;
            }
            console.log("Parando simulação automaticamente...");
            isRunning = false; // Define a flag para falso IMEDIATAMENTE

            clearInterval(timer); // Garante que o timer seja parado
            clearInterval(simulationInterval); // Garante que o loop principal seja parado
            if (checkEndTimeoutId) clearTimeout(checkEndTimeoutId); // Limpa qualquer timeout de verificação pendente

            console.log("-> PREPARANDO PARA ALERTA DE FIM DE SIMULAÇÃO..."); // NOVO LOG AQUI
            // Exibe o alerta com o tempo final ANTES de resetar elapsedTime
            alert(`Simulação Concluída! Todos os pacotes chegaram ao destino em ${elapsedTime.toFixed(2)} segundos.`);
            console.log("-> ALERTA DE FIM DE SIMULAÇÃO EXIBIDO."); // NOVO LOG AQUI

            // Limpa todos os pacotes e elementos de trânsito
            resetSimulation(); // resetSimulation já faz as limpezas visuais e de arrays

            // Reset do timer (após o alerta)
            elapsedTime = 0;
            updateTimerDisplay(); // Atualiza o display para 0.00

            // Atualiza estados dos botões
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            resumeBtn.disabled = true;
            stopBtn.disabled = true;
            console.log("Simulação COMPLETAMENTE parada. Timer zerado.");
        }

        // Reinicia a simulação (limpa tudo para um novo início)
        function resetSimulation() {
            console.log("Reiniciando simulação...");
            // Remove todos os pacotes dos buffers
            document.querySelectorAll('.buffer').forEach(buffer => {
                Array.from(buffer.children).forEach(child => {
                    if (child.classList.contains('packet')) {
                        buffer.removeChild(child);
                    }
                });
            });

            // Remove todos os pacotes em trânsito do DOM
            packetsInTransit.forEach(p => {
                if (p.parentNode) {
                    p.parentNode.removeChild(p);
                }
            });
            packetsInTransit = []; // Limpa o array de pacotes em trânsito

            packets = []; // Limpa a lista global de todos os fragmentos criados

            // Garante que os intervalos estejam limpos
            clearInterval(timer);
            clearInterval(simulationInterval);
            if (checkEndTimeoutId) clearTimeout(checkEndTimeoutId);
            console.log("Simulação resetada. Buffers e links limpos.");
        }

        // Inicia o timer (ou reinicia se já estiver rodando)
        function startTimer() {
            clearInterval(timer); // Limpa qualquer timer existente para evitar duplicidade
            timer = setInterval(() => {
                elapsedTime += 0.01;
                updateTimerDisplay();
            }, 10);
            console.log("Timer iniciado/reiniciado. Novo Timer ID:", timer);
        }

        // Atualiza o display do timer
        function updateTimerDisplay() {
            timerElement.textContent = `TEMPO DECORRIDO: ${elapsedTime.toFixed(2)}`;
        }

        // O loop principal da simulação
        function moveNextPacket() {
            if (!isRunning) return;

            // Prioridade 1: Movimentos de Transmissão (Buffer T para Link)
            // Pacotes saem dos buffers de transmissão para os links
            movePacketFromNode('nodeC_T', 'destR', 'link3');
            movePacketFromNode('nodeB_T', 'nodeC_R', 'link2');
            movePacketFromNode('sourceT', 'nodeB_R', 'link1');

            // Prioridade 2: Movimentos Internos de Buffers (dentro do nó)
            // Ordem estratégica: de R para B, de B para T
            moveInternalPackets('nodeB_R', 'nodeB_B');
            moveInternalPackets('nodeB_B', 'nodeB_T');

            moveInternalPackets('nodeC_R', 'nodeC_B');
            moveInternalPackets('nodeC_B', 'nodeC_T');

            // Importante: mover de destR para destB. Isso deve ser processado o mais rápido possível.
            moveInternalPackets('destR', 'destB');

            // Por último, a fonte continua empurrando pacotes para a rede
            moveInternalPackets('sourceB', 'sourceT');

            // Agendamos a verificação de término com um atraso GARANTIDO.
            // Use um valor maior que o animationSpeed para ter certeza que todos os movimentos daquele 'tick'
            // e as animações de link associadas tiveram tempo de se completar e serem adicionadas aos buffers.
            if (checkEndTimeoutId) clearTimeout(checkEndTimeoutId);
            checkEndTimeoutId = setTimeout(checkSimulationEnd, animationSpeed + 100); // Ex: Se animationSpeed=200, será 300ms.
        }

        // Move pacotes entre buffers dentro do mesmo nó
        function moveInternalPackets(sourceId, targetId) {
            const sourceBuffer = document.getElementById(sourceId);
            const targetBuffer = document.getElementById(targetId);

            if (!sourceBuffer || !targetBuffer) return false;

            // LOGS DE DEPURACAO AQUI, NO INICIO DA FUNCAO PARA destR -> destB
            if (sourceId === 'destR' && targetId === 'destB') {
                console.log(`[DEBUG - Internal Move] Tentando mover de destR para destB...`);
                console.log(`[DEBUG - Internal Move] Pacotes em destR: ${sourceBuffer.querySelectorAll('.packet').length}`);
                console.log(`[DEBUG - Internal Move] Pacotes em destB: ${targetBuffer.querySelectorAll('.packet').length}`);
            }

            // Encontra o pacote mais antigo no buffer de origem (o que está mais embaixo visualmente)
            const packet = sourceBuffer.querySelector('.packet');

            if (packet) {
                if (sourceId === 'destR' && targetId === 'destB') {
                    console.log(`[DEBUG - Internal Move] Pacote encontrado em destR: ${packet.dataset.id}`);
                }
                // Verifica se há espaço no buffer de destino
                const packetsInTarget = targetBuffer.querySelectorAll('.packet').length;
                if (packetsInTarget < BUFFER_CAPACITY) {
                    if (sourceId === 'destR' && targetId === 'destB') {
                        console.log(`[DEBUG - Internal Move] Espaço disponível em destB. Movendo ${packet.dataset.id} para destB.`);
                    }
                    sourceBuffer.removeChild(packet);
                    reorganizePacketsInBuffer(sourceId);

                    packet.dataset.location = targetId; // Atualiza a localização lógica do pacote
                    targetBuffer.appendChild(packet);
                    reorganizePacketsInBuffer(targetId);

                    // Se o pacote chegou ao buffer final (destB), atualiza seu status
                    if (targetId === 'destB') {
                        packet.dataset.status = 'at-destB';
                        console.log(`[STATUS UPDATE] Fragmento ${packet.dataset.id} AGORA está em destB. Status: ${packet.dataset.status}`);
                    }
                    return true;
                } else {
                    if (sourceId === 'destR' && targetId === 'destB') {
                        console.warn(`[DEBUG - Internal Move] destB está CHEIO. Não é possível mover ${packet.dataset.id}.`);
                    }
                }
            } else {
                if (sourceId === 'destR' && targetId === 'destB') {
                    console.log(`[DEBUG - Internal Move] Nenhum pacote encontrado em destR para mover para destB.`);
                }
            }
            return false;
        }

        // Move pacotes entre nós através dos links
        function movePacketFromNode(sourceId, targetReceptionBufferId, linkId) {
            const sourceBuffer = document.getElementById(sourceId);
            const link = document.getElementById(linkId);

            if (!sourceBuffer || !link) return false;

            const packetToMove = sourceBuffer.querySelector('.packet'); // Pegar o primeiro pacote (o mais "antigo")

            // Verifica se o link já está ocupado por outro pacote
            const isLinkOccupied = packetsInTransit.some(p => p.dataset.link === linkId);

            if (packetToMove && !isLinkOccupied) {
                // Remove o pacote do buffer de origem (visualmente)
                sourceBuffer.removeChild(packetToMove);
                reorganizePacketsInBuffer(sourceId);

                // Cria o pacote em trânsito (visualização do pacote no link)
                const transitPacket = document.createElement('div');
                transitPacket.className = 'packet-in-transit';
                // Copia classes de grupo de cor
                Array.from(packetToMove.classList).forEach(cls => {
                    if (cls.startsWith('packet-group')) {
                        transitPacket.classList.add(cls);
                    }
                });
                // Copia a classe 'fragment' se existir
                if (packetToMove.classList.contains('fragment')) {
                    transitPacket.classList.add('fragment');
                }

                transitPacket.dataset.id = packetToMove.dataset.id;
                transitPacket.dataset.packetGroup = packetToMove.dataset.packetGroup;
                transitPacket.dataset.link = linkId;
                transitPacket.dataset.targetBufferId = targetReceptionBufferId;
                transitPacket.textContent = packetToMove.textContent;
                transitPacket.style.height = packetToMove.style.height;

                // Posiciona o pacote no início do link
                const linkRect = link.getBoundingClientRect();
                const networkRect = document.querySelector('.network').getBoundingClientRect();
                transitPacket.style.left = `${linkRect.left - networkRect.left}px`;
                transitPacket.style.top = `${linkRect.top - networkRect.top + (linkRect.height / 2) - (transitPacket.offsetHeight / 2)}px`;

                document.querySelector('.network').appendChild(transitPacket);
                packetsInTransit.push(transitPacket);

                let transitTime = animationSpeed; // Baseado na velocidade global
                if (delays[linkId]) {
                    transitTime = animationSpeed * 2; // Duplica o tempo com delay
                }

                animatePacketOnLink(transitPacket, link, transitTime, packetToMove); // Passa a referência do pacote original
                return true;
            }
            return false;
        }

        // Anima o movimento de um pacote pelo link
        // Adicionado 'originalPacketRef' para que possamos atualizar o status do pacote REAL no array 'packets'
        function animatePacketOnLink(transitPacket, link, transitTime, originalPacketRef) {
            const linkRect = link.getBoundingClientRect();
            const networkRect = document.querySelector('.network').getBoundingClientRect();
            const targetBuffer = document.getElementById(transitPacket.dataset.targetBufferId);

            const endX = linkRect.right - networkRect.left - transitPacket.offsetWidth;

            const startTime = Date.now();
            const startX = parseInt(transitPacket.style.left);
            const distance = endX - startX;

            function step() {
                if (!isRunning) { // Se a simulação foi parada, remove o pacote em trânsito
                    if (transitPacket.parentNode) {
                        transitPacket.parentNode.removeChild(transitPacket);
                    }
                    packetsInTransit = packetsInTransit.filter(p => p !== transitPacket);
                    return;
                }

                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / transitTime, 1);

                const currentX = startX + (distance * progress);
                transitPacket.style.left = `${currentX}px`;

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    // Animação concluída, remover pacote em trânsito do DOM e do array packetsInTransit
                    if (transitPacket.parentNode) {
                        transitPacket.parentNode.removeChild(transitPacket);
                    }
                    packetsInTransit = packetsInTransit.filter(p => p !== transitPacket);

                    // Adicionar ao buffer de destino apenas se houver espaço
                    const packetsInTarget = targetBuffer.querySelectorAll('.packet').length;
                    if (packetsInTarget < BUFFER_CAPACITY) {
                        // Reutiliza o elemento DOM original (originalPacketRef) em vez de criar um novo
                        // Isso é crucial para manter a referência no array 'packets' consistente.
                        const newPacketDOM = originalPacketRef; // É o mesmo objeto DIV criado no início
                        newPacketDOM.className = 'packet'; // Garante que ele tenha a classe base 'packet'
                        
                        // Garante que as classes de grupo e fragmento são mantidas (se o transitPacket as tinha)
                        // Não precisamos copiar de transitPacket aqui, pois newPacketDOM já tem essas classes do início
                        // Apenas remove classes que não são mais relevantes para um pacote em buffer.
                        newPacketDOM.classList.remove('packet-in-transit'); 

                        newPacketDOM.dataset.location = targetBuffer.id;
                        newPacketDOM.dataset.status = 'waiting'; // Estado intermediário, será atualizado para 'at-destB' se for o destB
                        
                        // DEPURACAO: Verifique se originalPacketRef é o mesmo objeto que está no array 'packets'
                        if (originalPacketRef && packets.includes(originalPacketRef)) {
                            console.log(`[DEBUG - ANIMATION END] Packet ID: ${originalPacketRef.dataset.id} chegou em ${targetBuffer.id}. originalPacketRef é válido e está no array 'packets'.`);
                        } else {
                            console.error(`[CRITICAL ERROR - ANIMATION END] originalPacketRef para ID ${transitPacket.dataset.id} é INVÁLIDO ou NÃO está no array 'packets' após a animação!`);
                        }

                        targetBuffer.appendChild(newPacketDOM); // Adiciona o elemento DOM original ao novo buffer
                        reorganizePacketsInBuffer(targetBuffer.id);

                        // Se o pacote chegou ao buffer de recepção do destino, tentamos movê-lo para destB imediatamente
                        // Isso é uma FORÇA para o pacote ir para o destino final se o destB tiver espaço.
                        if (targetBuffer.id === 'destR') {
                            moveInternalPackets('destR', 'destB');
                        }

                    } else {
                        console.warn(`[DISCARDED] Buffer ${targetBuffer.id} cheio! Pacote ${transitPacket.dataset.id} descartado. ISSO PODE IMPEDIR A SIMULAÇÃO DE TERMINAR.`);
                        // Se um pacote for descartado, ele nunca chegará ao destB.
                        // Para que a simulação termine, pacotes descartados DEVERIAM ter seu status atualizado
                        // para algo como 'discarded', e a lógica de fim precisaria lidar com isso.
                        if(originalPacketRef) {
                            originalPacketRef.dataset.status = 'discarded'; // Marcar como descartado
                            console.warn(`[DISCARDED STATUS] Pacote ${originalPacketRef.dataset.id} marcado como 'discarded'.`);
                        }
                    }
                }
            }
            requestAnimationFrame(step);
        }

        // Reorganiza os pacotes em um buffer para visualização adequada (empilhamento)
        function reorganizePacketsInBuffer(bufferId) {
            const buffer = document.getElementById(bufferId);
            if (!buffer) return;

            const packetsInThisBuffer = Array.from(buffer.children).filter(el => el.classList.contains('packet'));

            packetsInThisBuffer.forEach((packet, index) => {
                packet.style.bottom = `${index * 12}px`; // 10px altura + 2px espaçamento
            });
        }

        // Função principal de verificação de término da simulação
        function checkSimulationEnd() {
            if (!isRunning) {
                console.log("checkSimulationEnd: Simulação não está rodando. Ignorando.");
                return;
            }

            // Condição 1: Todos os fragmentos criados (rastreados no array 'packets') chegaram ao destB
            // Verificamos se cada fragmento no array 'packets' tem o status 'at-destB'.
            let allFragmentsReachedDest = true;
            let fragmentsAtDestBCount = 0;
            let discardedFragmentsCount = 0;

            packets.forEach(p => {
                if (p.dataset.status === 'at-destB') {
                    fragmentsAtDestBCount++;
                } else if (p.dataset.status === 'discarded') {
                    discardedFragmentsCount++;
                    // Se permitirmos descartes para o fim da simulação, isso deve ser ajustado
                    // Por enquanto, descartados impedem o 'allFragmentsReachedDest' de ser true
                    allFragmentsReachedDest = false;
                    console.log(`[STATUS CHECK] Fragmento ${p.dataset.id} (Grupo: ${p.dataset.packetGroup}) foi DESCARTADO. Isso impedirá o término se não for gerenciado.`);
                }
                else {
                    allFragmentsReachedDest = false;
                    console.log(`[STATUS CHECK] Fragmento ${p.dataset.id} (Grupo: ${p.dataset.packetGroup}) NÃO está em destB. Status atual: ${p.dataset.status}, Local: ${p.dataset.location}`);
                }
            });

            // Se packets.length for 0, o 'every' no caso de um array vazio retorna true, então precisamos de um mínimo de pacotes
            if (packets.length === 0) {
                allFragmentsReachedDest = false; // Nenhuma mensagem foi criada ainda para terminar.
                console.log("[STATUS CHECK] NENHUM fragmento foi criado (packets.length é 0).");
            } else if (fragmentsAtDestBCount + discardedFragmentsCount < packets.length) {
                // Se o número de pacotes em destB + descartados ainda não é igual ao total de pacotes criados,
                // significa que ainda há pacotes presos ou em trânsito que não foram contabilizados.
                allFragmentsReachedDest = false;
            }


            // Condição 2: Não há pacotes mais em trânsito (nos links)
            const noPacketsInTransit = packetsInTransit.length === 0;
            if (!noPacketsInTransit) {
                console.log(`[TRANSIT CHECK] Pacotes AINDA em trânsito: ${packetsInTransit.map(p => p.dataset.id).join(', ')}`);
            }

            // Condição 3: Não há pacotes esperando na fonte (buffers sourceB e sourceT)
            const sourceBPkts = document.getElementById('sourceB').querySelectorAll('.packet').length;
            const sourceTPkts = document.getElementById('sourceT').querySelectorAll('.packet').length;
            const noPacketsAtSource = sourceBPkts === 0 && sourceTPkts === 0;
            if (!noPacketsAtSource) {
                console.log(`[SOURCE CHECK] Pacotes AINDA na fonte: sourceB=${sourceBPkts}, sourceT=${sourceTPkts}`);
            }

            console.log(`--- Check End Summary (${elapsedTime.toFixed(2)}s) ---`);
            console.log(`Total Fragmentos Criados: ${packets.length}`);
            console.log(`Fragmentos com status 'at-destB': ${fragmentsAtDestBCount}`);
            console.log(`Fragmentos com status 'discarded': ${discardedFragmentsCount}`);
            console.log(`ALL FRAGMENTS REACHED DESTB (or discarded): ${allFragmentsReachedDest}`); // Nome ajustado para clareza
            console.log(`NO PACKETS IN TRANSIT: ${noPacketsInTransit}`);
            console.log(`NO PACKETS AT SOURCE: ${noPacketsAtSource}`);
            console.log(`Visualmente no destB: ${document.getElementById('destB').querySelectorAll('.packet').length} pacotes`);

            // A simulação termina se:
            // 1. Todos os fragmentos que foram gerados (e estão no array `packets`) chegaram ao destino final (destB) OU foram descartados.
            // 2. Não há pacotes em trânsito nos links.
            // 3. Não há mais pacotes para serem enviados da fonte.
            if (allFragmentsReachedDest && noPacketsInTransit && noPacketsAtSource) {
                console.log("TODAS AS CONDIÇÕES DE FIM DE SIMULAÇÃO ATINGIDAS. Chamando stopSimulation()...");
                stopSimulation();
            } else {
                console.log("Condições para o fim da simulação AINDA NÃO ATINGIDAS.");
            }
        }
    </script>
</body>
</html>